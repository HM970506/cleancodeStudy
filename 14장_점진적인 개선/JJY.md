💡 점진적인 개선을 보여주는 사례에 대해서 알아보자

# Args 구현
명령행 인수의 구문을 분석하는 args 유틸리티를 구현해보자! 🙋🏻‍♀️
>
저자가 만든 args 유틸리티는 생성자에 인수 문자열과 형식 문자열을 넘겨 Args 인스턴스를 생성한 후 Args 인스턴스에 인수값을 질의힌다.

깨끗한 코드를 짜기 위해서는 지전분한 코드를 짠 뒤에 점진적으로 개선해 나가야한다.
위 유틸리티는 점진적인 개선을 통해 깨끗한 코드가 완성되었으며, 아래는 개선 과정을 보여준다.


## 🔸 Arags: 1차 초안
#### 코드는 돌아가지만 엉망인 코드
- 너무 많은 인스턴스 변수의 개수
- 희한한 문자열의 등장
- HashSets, TreeSets, try-catch-catch 블록
- 인수 유형을 추가할수록 지저분해짐
### 그래서 멈췄다.
- 저자는 코드 구조를 유지보수하기 좋은 상태로 만들기 위해 기능 추가를 멈추고 리팩터링을 하기로 결정했다.
- 먼저, 새 인수 유형을 추가하기 위해 코드를 추가할 수 있는 지점을 찾아낸다.
- 인수 유형은 다양하지만 모두가 유사한 메서드를 제공하므로 ArgumentMarshler 클래스를 만들게 된다.
### 점진적으로 개선하다
- 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위이다. 
- 저자는 테스트 주도 개발(TDD) 기법을 사용해서 위험을 최대한 피하고자 하였다.
( TDD는 언제 어느때라도 시스템이 돌아가야 하며, 시스템을 망가뜨리는 변경을 허용하지 않음 )
- 따라서, 클래스를 구현하기 전에 단위 테스트 슈트와 인수 테스트를 만들어 프로그램을 전진적으로 개선시켰다.
> #### 😒 리팩터링 결과
> 구조는 조금 개선되었다.
> 하지만, 첫머리의 변수는 그대로 남아있고, setArgument에는 유형을 일일이 확인하는 보기 싫은 코드도 그대로 남아있으며
> 오류 처리 코드와 모든 set 함수는 보기에 흉하다.
## 🔸 리팩터링 한 번 더
- setArgument 함수에서 유형을 일일이 확인하는 코드를 없애고, ArgumentMarshaler 파생 클래스로 내린다.
- 이때 인스턴스 변수를 2개 넘기면 코드가 지저분해지기 때문에 args를 list로 변환한 후 Iterator를 set 함수로 전달한다.
- 모든 예외를 하나로 모아 ArgsException 클래스를 만든 후 독자 모듈로 옮긴다.

## 🔸 결론
- 나쁜 코드를 깨끗한 코드로 개선할 수 있지만 비용이 엄청나게 많이 든다.
- 처음부터 코드를 깨끗하게 유지하기란 상대적으로 쉽다.
- 코드는 언제나 최대한 깔끔하고 단순하게 정리하자
