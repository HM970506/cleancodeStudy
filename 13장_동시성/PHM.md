# 동시성

## 동시성이 필요한 이유
> 동시성은 결합을 없애고 **무엇**과 **언제**를 분리하는 전략이다

* 스레드가 1개인 프로그램 - 무엇과 언제가 서로 밀접
* 무엇과 언제를 분리하면?
> 🤹‍♂️ 프로그램은 거대한 하나의 루프에서… <br/>
> ⚽⚾🥎🏀 작은 협력 프로그램 여럿으로 보인다! <br/>

<br/>

## 서블릿
* EJB 컨테이너에서 동시성을 부분적으로 관리
* 웹 요청이 들어올 때마다 서버는 **비동기식**으로 서블릿을 실행
* 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 실행됨

<br/>

## 🤔 동시성은 과연 완벽할까?
* 동시성은 항상 성능을 높여주는가? <br/>
 👉 동시성은 다음과 같은 상황에서는 성능 향상에 도움이 된다,
* 여러 프로세스가 동시에 처리해야 하는 독립적인 계산이 충분할 경우
* 여러 스레드가 프로세서를 공유해야 하는 경우
<br/>

* 동시성은 설계와 무관한가? <br/>
 👉 단일 스레드 시스템과 다중 스레드 시스템은 설계가 **판이하게** 다르다!
<br/>

* 웹 또는 EJB컨테이너를 사용하면 동시성을 몰라도 되는가? <br/>
👉 해당 상황에서 동시 수정, 데드락 등을 피하기 위해 동시성을 공부해야 한다!

<br/>

## 😏 동시성은 사실!
* 성능 측면에서 다소 부하를 발생시킨다.
* 간단한 문제도 복잡하게 접근한다.
* 동시성 버그는 재현이 어렵고 일회성 오류로 무시된다.
* 동시성을 구현하기 위해서는 근본적인 설계 전략의 재고가 필요하다.

<br/>

## 동시성을 구현하기 어려운 이유
>컴파일러의 구현 순서 배치에 따라 다른 결과가 나올 위험성이 존재!

<br/>

### 동시성 방어 원칙
> 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술

#### SRC(단일 책임 원칙)
* 동시성 관련 코드는 다른 코드와 분리한다
* 동시성 관련 코드를 작성할 때는 다음을 고려한다
	* 동시성 코드는 독자적인 개발, 변경, 조율 주기가 존재
	* 동시성 코드에는 다른 코드와 다른 난관이 존재
	* 잘못 구현한 동시성 코드는 많은 실패사유가 존재

<br/>
<br/>

#### 따름 정리(corollary)
* 캡슐화로 공유를 줄이고 자료 범위를 제한하라
	* 코드 내 임계영역을 synchronized 키워드로 보호하라
	> synchronzied : 여러개의 스레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 막는 개념

<br/>

* 자료 사본을 사용하라
	* 자료 공유 대신 객체를 복사하여 읽기 전용으로 사용하라
<br/>

* 스레드는 가능한 독립적으로 구현하라
	* 다른 스레드와 가능한 자료를 공유하지 않는다
	* 하나의 스레드는 하나의 클라이언트 요청을 처리한다
	* 정보를 비공유되는 출처에서 가져와 지역 변수에 저장한다

<br/>
<br/>

(*라이브러리는 자바 버전에 따라 상이하게 변하므로 생략)

<br/>


## 실행 모델을 이해하라

### 다중 스레드 관련 용어
* 한정 자원(bound resource): 다중 스레드 환경에서 사용하는 제한적인 자원
	ex)길이가 정해진 버퍼
* 상호 배제(mutual exclusion): 한번에 한 스레드만 자원을 사용할 수 있는 경우
* 기아 현상(starvation): 자원을 영원히 대기하는 현상
* 데드락(deadlock): 스레드들이 서로가 끝나기를 영원히 대기하는 현상
* 라이브락(livelock): 락을 거는 단계에서 스레드들이 서로를 방해하는 현상

<br/>

### 생산자-소비자
* 👨‍🌾생산자 스레드: 정보를 생성해 대기열에 넣고 소비자 스레드에게 신호를 보낸다
* 👩‍🍳소비자 스레드: 대기열 큐에서 정보를 가져와 사용한 후 생산자 스레드에게 신호를 보낸다.
* 🍞 즉, 대기열은 한정된 자원!
* 🔄 서로가 서로의 신호를 대기하는 상태에 빠질 가능성이 있다
 
<br/>

### 읽기-쓰기
* 👩‍🏫 읽기 스레드: 공유 자원을 사용한다
* 👨‍🔬 쓰기 스레드: 공유 자원을 갱신한다
* 📚 즉, 처리율(throughput)이 중요하다!
	* 처리율이 강조됨 👉 기아 현상이 생기거나 오래된 정보가 쌓인다
	* 갱신이 강조됨 👉 쓰기 스레드가 버퍼를 오랫동안 점유하여 처리율이 떨어짐
* 해법: 읽기 스레드가 없을 때까지 쓰기 스레드가 버퍼를 대기! (기아 상태 위험성o)

<br/>

### 식사하는 철학자들
>모든 철학자들이 옆사람이 포크를 다 쓰고 내려놓는 것을 기다리느라 아무도 식사를 하지 못하는 상황!
![image](https://user-images.githubusercontent.com/62527898/180656554-1da63c1b-a43f-4a39-a3ba-0721e636778f.png)


<br/>

## 동기화하는 메서드 사이 의존성을 이해하라
* 공유 객체 하나에는 메서드 하나만 사용하라
* 공유 객체 하나에 여러 메서드를 사용해야 하는 상황에서는 다음을 고려하라
	* 클라이언트에서 잠금: 클라이언트가 첫번째 메서드를 호출하기 전 ~ 마지막 메서드를 호출한 후까지 잠금 유지
	* 서버에서 잠금
		* 서버: 서버를 잠그고 모든 메서드 호출 후에 잠금 해제하는 **메서드** 존재
		* 클라이언트: 위 메서드를 **호출**
	* 연결 서버: 잠금 수행 중간 단계 생성 (서버변경x)

<br/>

## 동기화하는 부분을 작게 만들어라
* 임계영역은 synchronized keyword를 이용해 한 스레드에서만 가동시킬 수 있도록 락 설정
* 임계영역의 사용 장소와 크기를 최대한 줄일 것
> #### 임계영역
> 한번에 한 스레드만 사용할 수 있는 영역

<br/>

## 올바른 종료 코드는 구현하기 어렵다
* 데드락
* 생산자-소비자 스레드에서 하나의 스레드가 먼저 종료되어 차단 상태에 빠지는 현상

<br/>👉기존에 존재하는 종료 알고리즘을 사용할 것!

<br/>

## 스레드 코드 테스트하기
* 문제를 노출하는 테스트케이스를 작성하라
* 프로그램 설정과 시스템 설정, 부하를 바꿔가며 돌려라
* 테스트 실패시 원인을 추적하라

>스레드 코드 테스트 지침
* 이상한 실패는 잠정적 스레드 문제로 취급하라
* 순차 코드부터 제대로 작동하게 하라
	* POJO(평범한 자바 객체)에서 작동하는 코드를 늘려라
* 다중 스레드 사용 코드의 재사용성을 높여라
	* 다양한 환경에서의 테스트
	* 스레드 수 조절이 쉽도록 작성
* 프로세서 수보다 많은 스레드를 돌려라
>#### 스와핑
>현재 메모리에서 다른 저장공간으로 옮겨졌다 돌아왔다 하는 것.<br/>
>스와핑이 잦을수록 임계영역이 빠진 부분이나 데드락을 찾기 쉬워진다
* 다른 플랫폼에서 돌려라
* 보조 코드로 코드를 흔들어(jiggle) 강제로 실패를 일으켜라
	* wait, sleep, yield, priority등을 이용하여 코드 순서를 다양하게 실행해라
	* 테스트 자동화 도구를 이용하여 위 테스트를 진행해라

<br/>

## 결론
* SRP를 준수해라
* POJO를 사용해 스레드 사용 코드와 미사용 코드를 분리하고 하나씩만 테스트한다
* 동시성 오류의 잠정적 원인을 파악해라
* 공유 객체와 범위를 최대한 줄인다
* 많은 플랫폼에서 테스트하라

<br/>

