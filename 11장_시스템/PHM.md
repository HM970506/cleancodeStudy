# 11장 시스템

<br/>

## 시스템 제작과 시스템 사용을 분리하라

### 소프트웨어 시스템
* 준비 과정
	* 애플리케이션 객체 제작
	* 의존성 연결
* 런타임 로직 <br/>
👉 소프트웨어 시스템은 준비 과정와 런타임 로직을 분리해야 한다!

<br/>

### 초기화 지연(계산 지연)
```java
public Service getService(){
	if(service==null) service=new MyServiceImpl(...);
	return service;
}
```

👍 장점
* 실제 필요할 때까지 객체를 생성하지 않아 불필요한 부하를 줄인다
* 절대로 null을 반환하지 않는다

👎 단점
* …으로 생략된 생성자 인수에 명시적으로 의존한다
* 생성되는 객체가 한정되지 않아 테스트 수가 많아진다
* 일반 런타임과 객체생성을 모두 실행하는 함수이므로 단일 책임 원칙을 위반한다
* 해당 객체가 상황에 적확한지 확신할 수 없다


>![image](https://user-images.githubusercontent.com/62527898/180450558-8023c696-18a7-4629-9c87-4a93405bbd4e.png)
> 장점은 두개인데 단점은 다섯개입니다

👉 이러한 방법을 사용하여 모듈성을 해쳐서는 안 된다!

<br/>

### Main분리
시스템 생성과 시스템 사용을 분리하는 방법 <br/>
main에는 시스템에서 사용하는 객체 생성에 관련된 모든 코드가 존재한다고 가정

>#### 제어 흐름
>main: 애플리케이션에 일방적으로 의존된다 <br/>
>애플리케이션: main이나 객체가 생성되는 과정을 모른다
<br/>

### abstract factory pattern
객체가 생성되는 시점을 애플리케이션이 결정하는 구조 <br/>
시점과 넘기는 인수만을 애플리케이션이 결정하고, 여전히 객체 생성 과정은 모른다

<br/>
<br/>


### 의존성 주입(DI)
제어 역전 기법을 의존성 관리에 적용한 메커니즘
>#### 제어 역전
>한 객체가 맡은 보조 책임을 새로운 객체에게 떠넘겨 단일 책임 원칙을 지키는 방법
<br/>
<br/>

객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않는다...
<br/>

### 무슨 말인지 모르겠어서 다른 글을 찾아봤습니다
>"의존성"은 예를 들어 서비스로 사용할 수 있는 객체이고, "주입"은 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것을 의미한다. = 🤨예?

<br/>

> #### 😗 의존성은 이게 의존성 아닌가요?
> ```java
>public class Sandwich(){
> private Bread bread;
> public Sandwich(){
>	  bread=new Bread();
> }
>}
>
>public class Bread(){}
>//Bread를 생성하려면 반드시 Sandwich를 생성해야만 한다!
>//Bread를 Tortilla로 바꾸면 Sandwich의 모든 Bread부분을 수정해야만 한다!
>```
<br/>
 
>#### 😏 그래서 의존성을 없애려고 우리는 interface를 쓰지요
>```java
>public class Sandwich(){
>	private BreadInterface breadInterface;
>	public Sandwich(){
>		breadInterface = new Bread(); 
>		//인터페이스로 추상화된 공통 함수들을 가지므로,
>		//빵이든 또띠아든 상관이 없어진다!
>		//하지만 객체생성은 여전히 sandwich에게 의존중..
>   //샌드위치는 아직..빵을 알고 있다….!
> }
>}
>
>public interface BreadInterface breadInterface{
>	public void get();
>}
> 
>public class Bread implements BreadInterface{
>	public void get(){ System.out.println(“이것은 빵입니다”)}
>}
>
>public class Tortilla implements BreadInterface{
>	public void get(){ System.out.println(“이것은 또띠아입니다”)}
>}
>```
<br/>
 
> #### 🤯 그래서 그 의존성마저..없앴습니다!!
>```java
>public class Sandwich(){
>	private BreadInterface breadInterface;
>	public Sandwich(BreadInterface breadInterface){
>		//breadInterface = new Bread();
>		this.breadInterface = breadInterface;
>		//이제 샌드위치는 빵을 몰라요!!🤸‍♀️
>		//아는 것은 breadInterface뿐…
> }
>}
>```
<br/>
<br/>

>#### 😨 근데 이러면… BreadInterface 인자를 넣어주는 녀석이 책임을 뒤집어쓰게 되잖아요!
# 그것이 바로 의존성 주입이다!
<br/>
<br/>

#### 위키에서 말하는 의존성 주입
* 클라이언트가 서비스를 구축하거나 찾는 것을 허용하는 대신 클라이언트에게 서비스를 전달하는 것이 패턴의 기본 요건이다.
* 의존성 주입의 의도는 **객체의 생성과 사용의 관심을 분리**하는 것이다.
* 클라이언트가 주입자와 서비스 구성 방식 또는 사용중인 실제 서비스에 대해 알지 못해야 한다.
* 클라이언트는 대신 서비스 제공에 대한 책임을 외부 코드(주입자)로 위임한다.
* 클라이언트는 서비스의 사용 방식을 정의하고 있는 서비스의 고유한 인터페이스에 대해서만 알면 된다.
* "구성"의 책임으로부터 "사용"의 책임을 구분한다.<br/>
👉 즉, 만드는 놈 따로 있고 쓰는 놈 따로 있다… 문제가 생기면 전부 쓰는 놈 책임!!

<br/>

#### DI 컨테이너
필요한 객체의 인스턴스를 만든 후 생성자 메서드 등을 이용해 의존성을 설정하는 컨테이너 <br/>
실제로 생성되는 객체 유형은 설정 파일에서 지정하거나 특수 생성 모듈에서 명시한다
<br/>

![image](https://user-images.githubusercontent.com/62527898/180452556-5a510128-a624-43d0-99c3-8d2ea94839a0.png)
![image](https://user-images.githubusercontent.com/62527898/180452570-c5025b1e-c8c1-455a-bcdd-01ad4edd5793.png)

<br/>


(자료출처:  https://velog.io/@re-deok/%EC%8A%A4%ED%94%84%EB%A7%81-IoC-DI-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88)
<br/>
<br/>

#### 😳 DI컨테이너를 어디서 사용하는데?
자바 스프링에서 자바 DI컨테이너를 제공하고, 객체 사이 의존성을 XML파일에 정의한다!
<br/>

#### 😢그렇다면 초기화 지연으로 얻는 장점은 포기해야 할까?
대다수의 DI컨테이너는 필요할 때까지 객체를 생성하지 않아 계산 지연의 이점을 사용하면서 해당 메커니즘을 적용할 수 있다!

<br/>
<br/>

## 확장
> ‘처음부터 올바르게’ 시스템을 만들 수 있다는 믿음은 미신이다
<br/>

### 횡단(cross-cutting) 관심사
>#### 영속성(persistence)
>데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성
<br/>

😦로버트C.마틴은 결국.. 횡단 관심사가 뭔지 우리에게 설명하지 않았다.
<br/>

### 그래서 스스로 찾아본 횡단 관심사
핵심적인 기능이 아닌, 중간에 삽입되어야 하는 기능들을 일컫는 말 <br/>
ex) 중간 상황 메시지 출력 등.. <br/>
![image](https://user-images.githubusercontent.com/62527898/180453290-a2f1c26c-12b0-4751-a7a4-b6d3f84e042c.png)

<br/>
프로그램의 최종목적인 핵심관심과는 다르게 프로그램에 전체적으로 퍼져 있어 이를 횡단관심이라고 부른다.

<br/>
<br/>

### 관점 지향 프로그래밍(AOP)
횡단 관심사의 분리를 허용함으로써, 모듈성을 증가시키는 프로그래밍 기법
<br/>

>#### 😮 횡단 관심사를.. 분리해요? 어떻게요? 전체적으로 퍼져 있다면서!

기능을 비지니스 로직(핵심 관심) 과 공통 모듈(횡단 관심)로 구분한다. <br/>
공통모듈은 개발자의 코드 밖에서 필요한 시점에 비지니스 로직에 삽입하여 실행되도록 한다. <br/>
👉즉, 횡단 관심이 수정되어도 대상 코드인 핵심 관심에는 영향을 미치지 않는다! <br/>

<br/>

#### 자바에서 사용하는 AOP 메커니즘
* 자바 프록시 패턴: 자신의 기능에만 집중하고 나머지 역할을 객체에 위임하는 패턴
* 순수 자바 AOP 프레임워크: 프록시 코드의 자동화
* AspectJ 언어를 사용한 관심사 분리

<br/>

### 테스트 주도 시스템 아키텍처 구축

❌ Big design up Front를 할 필요가 없다..  <br/>
⭕ 아주 단순하고 분리된 아키텍처로 결과물을 빨리 출시하고 조금씩 확장하자! <br/>

<br/>

#### 의사 결정을 최적화하라
* 가능한 마지막 순간까지 결정을 미뤄라
* 최대한 정보를 모아 최선의 결정을 내려라

<br/>

#### 명백한 가치가 있을 때 표준을 현명하게 사용하라
* 작고 가벼운 프로젝트에서 굳이 표준을 사용할 필요는 없다
* 표준은 분명 기능적으로 좋지만, 필요할 때만 가져다 쓰자!

<br/>

#### 시스템은 도메인 특화 언어가 필요하다
>DSL - 간단한 스크립트언어로 구현한 API

<br/>

## 결론
* 모든 추상화 단계에서 의도를 명확히 표현해야 한다
* POJO(오래된 방식의 간단한 자바 오브젝트)를 작성해라
	* 실제로 돌아가는 가장 단순한 수단을 사용해라
* 각 구현 관심사를 분리하라

