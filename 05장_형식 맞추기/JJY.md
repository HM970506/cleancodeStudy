## **형식 맞추기**

형식을 깔끔하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실하게 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다. 필요하다면 규칙을 자동으로 적용하는 도구를 활용한다.

### **형식을 맞추는 목적**

코드 형식은 중요하다!  
코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무이다.  
오늘 구현한 코드의 가독성은 앞으로도 바뀔 코드의 품질에 지대한 영향을 미친다.  
오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다.  
원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다.

### **적절한 행 길이를 유지하라**

500 줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다.  
일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.

#### **_신문 기사처럼 작성하라_**  

> 소스 파일도 신문 기사와 비슷하게 작성한다. 이름은 간단하면서도 설명이 가능하게 짓는다.  
> 이름만 보고 올바른 모듈을 살펴보고 있는 지 아닌지를 판단할 정도로 신경 써서 짓는다.  
> 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다.  
> 아래로 내려갈수록 의도를 세세하게 묘사한다.  
> 마지막에는 가장 저차원 함수와 세부 내역이 나온다.

#### **_개념은 빈 행으로 분리하라_**

> 거의 모든 코드는 왼쪽에서 오른쪽으로 그리고 위에서 아래로 읽힌다.  
> 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다.  
> 생각 사이는 빈 행을 넣어 분리해야 마땅하다  
> 빈 행은 새로운 개념을 시작한다는 시각적 단서다.  
> 코드를 읽어 내려가다 보면 빈 행 바로 다음 줄에 눈길이 멈춘다.

#### **_새로 밀집도_**

> 줄바꿈이 개념을 분리한다면 밀집도는 연관성을 의미한다.  
> 즉, 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다.

#### **_수직 거리_**

> 서로 밀접한 개념은 세로로 가까이 두어야 한다.  
> 물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다.  
> 하지막 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다.  
> 이게 바로 protected 변수를 피해야 하는 이유 중 하나다.  
> (protected 변수 : 동일한 패키지 내에 존재하거나 파생클래스에서만 접근 가능한 변수)  
>   
> 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.  
> 여기서 연관성이란 한 개념을 이해하는 데 다른 개념이 중요한 정도다.  
> 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 뒤지게 된다.  
>   
 _**변수 선언**_  
> 변수는 사용하는 위치에 최대한 가까이 선언한다.  
> 우리가 만든 함수는 매우 짧으므로 지역 변수는 각 함수 맨 처음에 선언한다.  
>   
 _**루프를 제어하는 변수**_
> 루프를 제어하는 변수는 흔히 루프 문 내부에 선언한다.  
> (아주 드물지만 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다.)
>   
 _**인스턴스 변수**_ 
> 인스턴스 변수는 클래스 맨 처음에 선언한다.  
> 변수 간에 세로로 거리를 두지 않는다.  
> 잘 설계한 클래스는 많은 클래스 메서드가 인스턴스 변수를 사용하기 때문이다.  
> 자바에서는 보통 클래스 맨 처음에 인스턴스 변수를 선언한다.  
> 변수 선언을 어디서 찾을지 모두가 알고 있어야 한다.  
>   
_**종속 함수**_  
> 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.  
> 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.  
> 그러면 프로그램이 자연스럽게 읽힌다.  
>   
> 규칙을 일관적으로 적용한다면 독자는 방금 호출한 함수가 잠시 후에 정의되리라는 사실을 예측한다.  
> 첫째 함수에서 가장 먼저 호출되는 함수가 바로 아래 정의된다.  
> 다음으로 호출하는 함수는 그 아래에 정의된다.  
>   
> 그러므로 호출되는 함수를 찾기가 쉬워지며, 그만큼 모듈 전체의 가독성도 높아진다.  
>   
 _**개념적 유사성**_  
> 어떤 코드도 서로 끌어당긴다. 개념적인 친화도가 높기 때문이다.  
> 친화도가 높은 코드일수록 코드를 가까이 배치한다.  
>   
 _**친화도가 높은 예시**_  
> 한 함수가 다른 함수를 호출해 생기는 직접적인 종속성  
> 비슷한 동작을 수행하는 일군의 함수가 좋다.  
> 명명법이 똑같은 기본 기능이 유사하고 간단하다.   
>   
 _**세로 순서**_  
> 함수 호출 종속성은 아래 방향으로 유지한다,  
> 호출되는 함수를 호출하는 함수보다 나중에 배치한다.  
> 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.  
>   
> 가장 중요한 개념을 표현할 때에는 세세한 사항은 최대한 배제한다.  
> 세세한 사항은 가장 마지막에 표현한다.

### **가로 형식 맞추기**

짧은 행이 바람직하다.

독자는 개인적으로 120자 정도로 행 길이를 제한한다.

#### **_가로 공백과 밀집도_**

> 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.  
> 공백을 넣으면 두 가지 주요 요소가 확실히 나뉜다.  
> 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않는다.  
> 함수를 호출하는 코드에서 괄호 안 인수는 공백으로 분리한다.  
> 연산자 우선순위를 강조하기 위해서도 공백을 사용한다.  
> 승수 사이는 공백이 없다.  
> 항 사이에는 공백이 들어간다.

#### _**가로 정렬**_

> 특정 구조를 강조하고자 하는 가로 정렬과 같은 방식은 별로 유용하지 못하다.   
> 이와 같은 정렬은 코드가 엉뚱한 부분을 강조해 진짜 의도가 사라지기 때문이다.

#### _**들여쓰기**_

> 소스 파일은 윤곽도와 계층이 비슷하다.  
> 계층에서 각 수준은 이름을 선언하는 범위이자 선언문과 실행문을 해석하는 범위다.  
>   
> 이렇듯 범위로 이뤄진 계층을 표현하기 위해 우리는 코드를 들여쓴다.  
> 들여쓰는 정도는 계층에서 코드가 자리잡은 수준에 비례하다.  
>   
> 왼쪽으로 코드를 맞춰 코드가 속하는 범위를 시각적으로 표현한다.

#### _**가짜 범위**_

> 때로는 빈 while문과 for문을 접한다.   
> 이런 구조를 피하지 못할 때는 빈 블록을 올바로 들여쓰고 블록으로 감싼다.

### **팀 규칙**

팀에 속한다면 자신이 선호해야할 규칙이다.

팀은 한 가지 규칙에 합의해야 하며, 모든 팀원들은 그 규칙을 따라야 한다.

그래야 소프트웨어가 일관적인 스타일을 보인다.

좋은 소프트웨어 시스템은 일관적이고 매끄러워야 한다.

온갖 스타일을 섞어 소스 코드를 필요 이상으로 복잡하게 만드는 실수는 반드시 피해야 한다.

### **밥 아저씨의 형식 규칙**
