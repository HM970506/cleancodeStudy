부록A. 동시성2
===================
_이 부록은 동시성을 좀 더 자세히 설명하고 보완한다._   
<br>

### 클라이언트 / 서버 예제

_서버_  
단일 스레드 환경에서 속도를 끌어올릴 방법은 거의 없다.
>Q. 그렇다면 다중 스레드를 사용하면 성능이 높아질까?  
>A. 프로그램 별로 다르다. 프로세서 연산에 시간을 보내는 프로그램은 스레드를 늘린다고 빨라지지 않는다.

프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 한다.
시스템 한쪽이 I/O를 기다리는 동안 다른 쪽이 뭔가를 처리해 놓도록 CPU를 효과적으로 활용할 수 있기 때문이다.    
<br>

_스레드 추가하기_  
메시지 I/O를 수행하는 스레드를 추가한다.  
<br>

_서버 살펴보기_  
서버 프로그램은 `단일 책임 원칙(SRP)`을 위반한다.
다중 스레드 프로그램을 깨끗하게 유지하려면 잘 통제된 몇 곳으로 스레드 관리를 모아야 한다. 아니, __스레드를 관리하는 코드는 스레드만 관리해야 한다.__
이는 동시성 문제는 그 자체만으로도 추적하기 어렵기 때문이다.

즉, 스레드 관리 책임을 클래스로 분리한다면, 스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않는다.  
<br>

_결론_  
__동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서 `단일 책임 원칙`이 특히 중요하다.__    
<br><br>

### 가능한 실행 경로
스레드가 하나라면 메서드의 실행 경로는 단 하나다. 가능한 결과도 단 하나다.  
하지만 다중 스레드라면 실행 경로는 여러 개가 되고 다양한 결과가 나온다.  
이처럼 다양한 결과가 나오는 이유를 알려면 `실행 경로 수`와 `JVM의 동작 방식`을 알아야 한다.   
<br>

_가능한 순열 수 계산하기_  
단계가 N개이고 스레드가 T개라면 총 단계는 N * T개다.
각 단계를 실행하기 전에는 스레드 T개 중 하나를 선택하는 문맥 전환이 일어난다.
각 경로는 문맥 전환을 나타내는 일련의 순열로 표현할 수 있다.  
따라서, 경로 수는 `(N*T)!/(N!**T)`로 표현할 수 있다.

만약 `synchronized` 키워드를 이용해 메서드를 동기화한다면 가능한 경로 수는 `T!`개로 줄어든다.  
<br>

_심층 분석_  
`원자적 연산`이란 __중단이 불가능한 연산__ 을 말한다.
원자적 연산이면 두 스레드가 메서드를 한 번씩 호출해 같은 값을 얻는 시나리오가 가능하다.

```markdown
- 프레임(frame) - 모든 메서드 호출에는 프레임이 필요하다. 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수를 포함한다.  
- 지역 변수(local variables) - 메서드 범위 내에 정의되는 모든 변수를 가리킨다. 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역 변수를 갖는다. this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 베서드를 호출한 객체를 가리킨다. 
- 피연산자 스택(operand stack) - JVM이 지원하는 명령 대다수는 매개변수를 받는다. 피연산자 스택은 이런 매개변수를 저장하는 장소이다. 피연산자 스택은 표준 LIFO 자료구조다.
```
<br>

_결론_  
스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해 바이트 코드를 속속들이 이해할 필요는 없다.  
그렇기는 하지만, 어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다.  
즉, 다음을 알아야 한다.
- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법  
  <br><br>

### 라이브러리를 이해하라
_Executor 프레임워크_  
Executor 프레임워크는 스레드 풀링으로 정교한 실행을 지원한다.  
Executor 프레임워크는 스레드 풀을 관리하고, 풀 크기를 자동으로 조정하며, 필요하다면 스레드를 재사용한다.
또한 Future, Runnable, Callable 등 다양한 인터페이스와 클래스도 지원한다.  
<br>

_스레드를 차단하지 않는 방법_  
최신 프로세서는 차단하지 않고도 안정적으로 값을 갱신한다.  
다중 스레드 환경에서 값을 안전하게 갱신하기 위해 동기화를 수행한다. 즉, 스레드를 차단한다는 말이다.

__현대 프로세서는 흔히 `CAS(Compare and Swap)`라 불리는 연산을 지원하기 때문에 성능이 좋다.__  
`CAS`는 데이터베이스 분야에서 낙관적 잠금이라는 개념과 유사하다.
반면 동기화 버전은 비관적 잠금이라는 개념과 유사하다.

`synchronized` 키워드는 언제나 락을 건다.
자바 버전이 올라갈 때마다 내장 락의 성능이 좋아지기는 했지만 그래도 락을 거는 대가는 여전히 비싸다.
많은 스레드가 경쟁하는 상황이라도 __`락을 거는 쪽`보다 `문제를 감지하는 쪽`이 거의 항상 더 효율적이다.__  
`CAS 연산`은 원자적으로 동작함으로써 이를 달성한다.
`CAS 연산`은 값을 확인하여 다른 스레드가 끼어들었는지 판단하고 다른 스레드가 끼어들었다면 값을 갱신하지 않는다.    
<br>

_다중 스레드 환경에서 안전하지 않은 클래스_    
본질적으로 다중 스레드 환경에서 안전하지 않은 클래스가 있다.
참고로, 몇몇 집합 클래스는 스레드에 안전한 메서드를 제공한다.
하지만 그런 메서드 여럿을 호출하는 작업은 스레드에 안전하지 않다.

각 메서드는 스레드에 안전하다. 하지만 각 메서드의 진행 도중에 다른 스레드가 끼어들 위험성이 있다.   
<br><br>

### 메서드 사이에 존재하는 의존성을 조심하라
다중 스레드 환경에서 스레드가 서로 간섭하여 문제가 발생한다.  
해결 방안은 세 가지다.
- 실패를 용인한다.
- 클라이언트를 바꿔 문제를 해결한다. 즉, 클라이언트-기반 잠금 메커니즘을 구현한다.
- 서버를 바꿔 문제를 해결한다. 서버에 맞춰 클라이언트도 바꾼다. 즉, 서버-기반 잠금 메커니즘을 구현한다.  
  <br>

_실패를 용인한다_  
때로는 실패해도 괜찮도록 프로그램을 조정할 수 있다.  
<br>

_클라이언트-기반 잠금_  
잠금을 잊어버리는 바람에 오류가 발생할 확률이 높기 때문에 클라이언트-기반 잠금 메커니즘을 추천하지 않는다.  
<br>

_서버-기반 잠금_  
일반적으로 서버-기반 잠금이 더 바람직하다.  
이유는 다음과 같다.
```markdown
- 코드 중복이 줄어든다.
- 성능이 좋아진다.
- 오류가 발생할 가능성이 줄어든다.
- 스레드 정책이 하나다.  
- 공유 변수 범위가 줄어든다.
```
<br><br>

### 작업 처리량 높이기
다중 스레드 환경에서의 처리율이 단일 스레드 환경의 세 배이다.  
<br><br>

### 데드락
데드락을 근본적으로 해결하려면 원인을 이해해야 한다.
다음 네 가지 조건을 모두 만족하면 데드락이 발생한다.
- __상호 배제(Mutual exclusion)__
- __잠금 & 대기(Lock & Wait)__
- __선점 불가(No Preemption)__
- __순환 대기(Circular Wait)__  
  <br>

_상호 배제_  
여러 스레드가 한 자원을 공유하나 그 자원은
```markdown
- 여러 스레드가 동시에 사용하지 못하며
- 개수가 제한적이라면
```
상호 배제 조건을 만족한다.

_잠금 & 대기_  
일단 스레드가 자원을 점유하면 필요한 나머지 지원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.

_선점 불가_  
한 스레드가 다른 스레드로부터 자원을 빼앗지 못한다.

_순환 대기_  
다중 스레드 환경에서 스레드가 서로 필요한 리소스를 점유하고 있어서 순환 대기하는 상황이다.  
<br>

_상호 배제 조건 깨기_  
데드락을 피하는 전략 중 하나가 상호 배제 조건을 비껴가는 방법이다.  
구체적으로는
```markdown
- 동시에 사용해도 괜찮은 자원을 사용한다.  
- 스레드 수 이상으로 자원 수를 늘린다.  
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.  
```
<br>  

_잠금 & 대기 조건 깨기_   
대기하지 않으면 데드락이 발생하지 않는다.  
따라서, 각 자원을 점유하기 전에 확인하고, 만약 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작한다.

이 방법은 잠재적인 문제가 몇 가지 있다.
```markdown
- 기아(Starvation) - 한 스레드가 계속해서 필요한 자원을 점유하지 못한다.
- 라이브락(Livelock) - 여러 스레드가 한꺼번에 잠금 단계로 진입하는 바람에 계속해서 자원을 점유했다 놨다를 반복한다.
```
두 경우 모두가 자칫하면 작업 처리량을 크게 떨어뜨린다.  
`기아`는 CPU 효율을 저하시키는 반면 `라이브락`은 쓸데 없이 CPU만 많이 사용한다.  
<br>

_선점 불가 조건 깨기_  
데드락을 피하는 또 다른 전략은 다른 스레드로부터 자원을 뺏어오는 방법이다.  
일반적으로 간단한 요청 메커니즘을 처리하지만 모든 요청을 관리하기가 그리 간단하지 않다.  
<br>

_순환 대기 조건 깨기_  
모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 데드락은 불가능하다.
그러나 어느 전략과 마찬가지로 이 전략 역시 문제를 일으킬 소지가 있다.  
<br>

__이렇게 데드락을 피하는 전략은 많다. 그리고 각 전략에 따른 장단점이 존재한다.__  
프로그램에서 스레드 관련 코드를 분리하면 조율과 함께 실험이 가능하므로 통찰력이 높아져 최적의 전략을 찾기 쉬워진다.  
<br><br>

### 다중 스레드 코드 테스트
코드에 버그가 있다는 사실을 밝혀낼 테스트 케이스는 어떻게 작성할까?
다음은 몇 가지 아이디어다.

- 몬테 카를로 테스트  
  조율이 가능하게 유연한 테스트를 만든다. 그런 다음, 임의로 값을 조율하면서 반복해 돌린다.
- 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다.
- 부하가 변하는 장비에서 테스트를 돌린다.

하지만 위와 같은 조치를 모두 취하더라도 코드에서 스레드 문제를 찾아낼 가능성은 매우 낮다.  
<br>

_스레드 코드를 도와주는 도구_  
IBM은 ConTest라는 도구를 내놓았다. 그레드에 안전하지 않는 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구이다.  
<br>

__결론__  
여기서는 __다중 스레드 코드를 깨끗하게 유지하는 방법__ 을 익혔다.
하지만 다중 스레드 시스템을 구현하려면 알아야 할 내용이 아주 많다.

이 장에서는 `동시 갱신`을 논했으며, `동시 갱신을 방지하는 깨끗한 동기화/잠금 기법`을 소개했다.
`스레드가 I/O 위주 시스템의 처리율을 높여주는 이유`와 `실제로 처리율을 높이는 방법`을 살펴봤다.
`데드락`을 논했으며, `깔끔하게 데드락을 방지하는 기법`도 열거했다.
마지막으로 `보조 코드를 추가해 동시성 문제를 사전에 노출하는 전략`을 소개했다.  

