
## ✅ 주석
주석은 코드와 설계에 기술적인 설명을 부연하는 수단
### C1 : 부적절한 정보
- 다른 시스템에 저장할 정보는 주석으로 적절하지 못하다.
- 작성자, 최종 수정일, SPR 번호 등과 같은 메타 정보만 주석을 넣는다.
### C2 : 쓸모없는 주석
- 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없다.
- 쓸모 없는 주석은 아예 달지 않는 편이 가장 좋으며, 쓸모 없어진 주석은 재빨리 삭제하는 편이 가장 좋다.
### C3 : 중복된 주석
- 구구절절 설명하는 주석은 중복된 주석이다.
- 주석은 코드만으로 다하지 못하는 설명을 부언한다.
### C4 : 성의없는 주석
- 작성할 가치가 있는 주석은 잘 작성할 가치도 있다.
- 단어는 신중히! 문법과 구두점은 올바르게! 간결하고 명료하게!
### C5 : 주석 처리된 코드
- 주석으로 처리되 코드를 발견하면 즉각 삭제한다.
---
## ✅ 환경
### E1 : 여러 단계로 빌드해야 한다
- 빌드는 간단히 한 단계로 끝나야 한다.
- 불가해한 명령이나 스크립트를 잇달아 실행해 각 요소를 따로 빌드할 필요가 없어야 한다.
- 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.
### E2 : 여러 단계로 테스트해야 한다
- 모든 단위테스트는 한 명령으로 돌려야 한다.
---
## ✅ 함수
### F1 : 너무 많은 인수
- 함수에서 인수의 개수는 작을수록 좋다.
- 넷 이상은 최대한 피한다.
### F2 : 출력 인수
- 출력 인수를 사용하지 말고 함수가 속한 객체의 상태를 변경한다.
### F3 : 플래그 인수
- 플래그 인수는 혼란을 초래하므로 피해야 한다.
### F4 : 죽은 함수
- 아무도 호출하지 않는 함수는 삭제한다.
---
## ✅ 일반
### G1 : 한 소스 파일에 여러 언어를 사용한다
- 소스 파일 하나에 언어 하나만 사용하는 방법이 가장 좋다.
- 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 노력하자.
### G2 : 당연한 동작을 구현하지 않는다.
- 함수나 클래스는 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.
- 함수 이름만으로 함수 기능을 직관적으로 예상할 수 있도록 해야한다.
### G3 : 경계를 올바로 처리하지 않는다.
- 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.
### G4 : 안전 절차 무시
- 실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 매우 위험하다.
### G5 : 중복
- 코드에서 중복을 발견할 때마다 추상화를 기회로 간주하라.
- 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라.
  - 똑같은 코드가 여러 차례 등장 → 간단한 함수로 교체
  - 조건을 거듭 확인하는 중복 → 다형성으로 대체
- 어디서든 중복을 발견하면 없애라.
### G6 : 추상화 수준이 올바르지 못하다
- 추상화로 개념을 분리할 때는 철저해야 한다.
- 저차원 개념과 고차원 개념을 섞으면 안된다.
### G7 : 기초 클래스가 파생 클래스에 의존한다
- 기초 클래스가 파생 클래스를 사용하면 안된다.
- 기초 클래스는 파생 클래스를 아예 몰라야 마땅하다.
### G8 : 과도한 정보
- 클래스나 모듈 인터페이스에 노출할 함수를 제한할 줄 알아야 한다.
- 인터페이스를 매우 작게 깐깐하게 만들어야 하며, 정보를 제한해 결합도를 낮춰야 한다.
### G9 : 죽은 코드
- 죽은 코드란 실행되지 않은 코드를 가리킨다.
- 죽은 코드를 발견하면 시스템에서 제거해야 한다.
### G10 : 수직 분리
- 변수와 함수는 사용되는 위치에 가깝게 정의한다.
### G11 : 일관성 부족
- 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현해야 한다. 
- 이렇게 적용하면 코드를 읽고 수정하는 것이 수월해진다.
### G12 : 잡동사니
- 비어 있는 기본 생성자, 아무도 사용하지 않는 변수, 호출하지 않는 함수 등은 제거한다.
### G13 : 인위적 결합
- 서로 무관한 개념을 인위적으로 결합하지 않는다. 
- 함수, 상수, 변수의 선언은 올바른 위치에 해야 한다.
### G14 : 기능 욕심
- 클래스 메서드는 자기 자신의 범위를 넘어서 다른 클래스의 변수나 함수에 관심을 가지면 안된다.
### G15 : 선택자 인수
- 선택자 인수는 목적을 기억하기 어렵기 때문에 사용하지 않은 것이 좋다.
- 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다.
### G16 : 모호한 의도
- 코드를 짤 때는 의도를 최대한 분명히 밝힌다.
### G17 : 잘못 지운 책임
- 코드는 독자가 자연스럽게 기대할 위치에 배치한다.
### G18 : 부적절한 static 함수
- 일반적으로 static 함수보다 인스턴스 함수가 더 좋다.
- 반드시 static 함수를 정의할 때는 재정의 할 필요가 없는지 따져본다.
### G19 : 서술적 변수
- 프로그램의 가독성을 높일 수 있는 서술적인 변수는 많이 사용할수록 좋다.
### G20 : 이름과 기능이 일치하는 함수
- 이름만으로 기능이 분명하게 드러나야 한다.
- 만약 그러지 않다면 이름을 바꾸거나 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.
### G21 : 알고리즘을 이해하라
- 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인하라.
- 알고리즘이 올바른지 확인하고 이해할 수 있도록 함수를 깔끔하고 명확하게 재구성한다.
### G22 : 논리적 의존성은 물리적으로 드러내라
- 한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 한다.
- 의존하는 모든 정보를 명시적으로 요청하는 편이 좋다.

### G23 : If/Else 혹은 Switch/Case 문보다 다항성을 사용하라
- switch 문을 선택하기 전에 다형성을 먼저 고려한다.
### G24 : 표준 표기법을 따르라
- 팀은 업계 표준에 기반한 구현 표준을 따라야 한다.
- 팀이 정한 표준은 팀원들 모두가 따라야 한다.
### G25 : 매직 숫자는 명명된 상수로 교체하라
- 코드에서 숫자를 사용하지 말라.
- 숫자는 상수 뒤로 숨기는 것이 좋다.
### G26 : 정확하라
- 코드에서 무언가를 결정할 때는 정확히 결정한다.
- 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다.
### G27 : 관례보다 구조를 사용하라
- 설계 결정을 강제할 때는 규칙보다 관례를 사용한다. 
- 명명 관례도 좋지만 구조 자체를 강제하면 더 좋다.
### G28 : 조건을 캡슐화하라
- 부울 논리보다는 조건의 의도를 분명히 밝히는 함수로 표현하라.
### G29 : 부정 조건은 피하라
- 부정 조건이 긍정 조건보다 이해하기 어렵다. 
- 가능하면 긍정 조건으로 표현한다.
### G30 : 함수는 한 가지만 해야 한다
- 한 가지만 수행하는 좀 더 작은 함수 여럿으로 나누는 것이 좋다.
### G31 : 숨겨진 시간적인 결합
- 함수의 시간적인 결합을 숨겨서는 안된다. 
- 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백하기 드러낸다.
### G32 : 일관성을 유지하라
- 코드 구조에 이유를 알고, 그 이유를 코드 구조로 명백히 표현하라.
### G33 : 경계 조건을 캡슐화하라
- 경계 조건은 한 곳에서 별도로 처리한다.
- 경계 조건은 변수로 캡슐화하여 놓치지 않는다.
### G34 : 함수는 추상화 수준을 한 단계만 내려가야 한다
- 함수 내 모든 문장은 추상화 수준이 동일해야 한다.
- 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.
### G35 : 설정 정보는 최상위 단계에 둬라
- 추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안된다.
### G36 : 추이적 탐색을 피하라
- 한 모듈은 주변 모듈을 모를수록 좋다. 
- 모듈은 자신이 직접 사용하는 모듈만 알아야 한다.
---
## ✅ 자바
### J1 : 긴 import 목록을 피하고 와일드카드를 사용하라
- 패키지 안에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라.
### J2 : 상수는 상속하지 않는다
- 상수는 상속하지 않는다.
- 대신 static import를 사용한다.
### J3 : 상수 대 Enum
- enum은 마음껏 활용해도 좋다.
- enum은 이름이 부여된 열거체에 속한다.
- 상수보다 유연하고 서술적인 강력한 도구이다.
---
## ✅ 이름
### N1 : 서술적인 이름을 사용하라
- 이름은 성급하게 정하지 않는다.
- 서술적인 이름으로 신중하게 고른다.
- 소프트웨어가 진화하면 의미도 변하므로 선택한 이름이 적합한지 자주 되돌아본다.
### N2 : 적절한 추상화 수준에서 이름을 선택한다
- 구현을 드러내는 이름은 피하라.
- 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택한다.
### N3 : 가능하다면 표준 명명법을 사용하라
- 기존 명명법을 사용하는 이름은 이해하기 더 쉽다.
- 프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.
### N4 : 명확한 이름
- 함수나 변수의 목적을 정확히 밝히는 이름을 선택한다.
### N5 : 긴 범위는 긴 이름을 사용하라
- 이름의 길이는 범위의 길이에 비례해야 한다. 
- 범위가 5줄 안팎이라면 i나 j와 같은 변수 이름도 괜찮다.
### N6 : 인코딩을 피하라
- 이름에 유형 정보나 범위 정보를 넣어서는 안 된다.
---
## ✅ 테스트
### T1 : 불충분한 테스트
- 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.

### T2 : 커버리지 도구를 사용하라
- 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다. 
- 테스트가 불충분한 부분을 찾아낸다.

### T3 : 사소한 테스트를 건너뛰지 마라
- 사소한 테스트는 짜기도 쉽기 때문에 건너뛰지 마라.

### T4 : 무시한 테스트는 모호함을 뜻한다
- 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다.

### T5 : 경계 조건을 테스트하라
- 경계 조건에서는 특별히 신경써서 테스트한다.

### T6 : 버그 주변은 철저히 테스트하라
- 버그는 서로 모이는 경향이 있다.
- 버그 주변은 철저히 테스트한다.

### T7 : 실패 패턴을 살펴라
- 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다.

### T8 :테스트 커버리지 패턴을 살펴라
- 통과하는 테스트가 실행하거나 실행하지 않는 코드를 보면 실패 테스트 케이스의 원인이 드러난다.

### T9 :테스트는 빨라야 한다
- 테스트 케이스가 빨리 돌아가게 최대한 노력해야 한다.
