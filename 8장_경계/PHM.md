# 경계

<br/>

## 외부 코드 사용하기
>인터페이스 제공자👩: 더 많은 환경에서 돌아가도록 적용성을 넓히자! <br/>
>인터페이스 사용자👩‍🦰: 내 요구와 환경에 집중했으면 좋겠어! <br/>

#### 👉 이러한 견해 차이로 인해 시스템 경계에서 문제가 발생한다!

<br/>

### 제네릭스란?
제네릭 타입을 클래스와 메서드에 선언해 둠으로써 컴파일 시 타입을 체크하는 기능.

>😎 js에 비슷한 기능으로 TypeScript가 있다네

```java
Object a = new Object();                    (x)
Object<MyObject> b= new Object<MyObject>()  (o)
```
<br/>
👍 제네릭스를 사용하면 코드 가독성이 높아지고 올바른 객체 반환이 가능하다! <br/>
👎 그러나 수정이 번거롭고 사용자에게 불필요한 기능을 거를 수 없다. <br/>

<br/>

### 제네릭스를 사용하지 않으려면…
```java
public class myClass{
	private Object obj=new Object();
	//사용자에게 필요한 object를 위한 함수들
}
```
👉 즉, 캡슐화하여 클래스가 객체 유형과 기능을 관리하도록 한다!

<br/>

## 경계 살피고 익히기
> 때로는 우리 버그인지 라이브러리 버그인지 찾아내느라 오랜 디버깅으로 골치를 앓는다.

### 학습 테스트
외부코드를 위한 테스트케이스를 작성하여 익히는 방법
* 학습 테스트는 패키지가 예상대로 동작하는지 검증하고 호환성을 보장한다.
* 학습 테스트는 패키지가 새 버전으로 쉽게 이주할 수 있도록 돕는다.

<br/>

## 아직 존재하지 않는 코드 사용하기
### 어댑터 패턴
클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴. <br/>
인터페이스와 클래스 사이 호환성을 담당한다.

<br/>

## 깨끗한 경계
* 경계에 위치하는 코드는 깔끔히 분리하고 테스트케이스를 작성한다.
* 외부 패키지 호출 코드를 가능한 줄인다.
* 캡슐화시키거나 어댑터 패턴을 이용하여 인터페이스를 변환시켜 관리한다. <br/>
<br/>

😊이러한 방법을 통해 코드 가독성과 일관성을 높이고, 수정을 용이하게 할 수 있다.
