## 클라이언트/서버 예제
> 간단한 클라이언트/서버 애플리케이션.
> 서버는 소켓을 열어놓고 클라이언트가 연결하기를 기다린다.
> 클라이언트는 소켓에 연결해 요청을 보낸다. 

### 서버
> 전체 소스 코드는 441쪽 클라이언트/서버 - 단일스레드 버전 참조

애플리케이션이 어디서 시간을 보내는지
* I/O - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간 보냄.
* 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등에 시간 보냄.

대게 시스템은 둘 다 하느라 시간을 보내지만, 특정 연산을 살펴보면 대게 하나가 지배적이다.
* 프로세서 연산에 시간 - 새로운 하드웨어 추가해 성능을 높여 테스트 통과하는 방식이 적절.
* I/O 연산에 시간 - 동시성이 성능 높여주기도 함.


### 스레드 추가하기 
> 성능 테스트 실패해싿고 가정.
> 자료 처리량을 높여 테스트를 통과할 방법은?
* 서버의 process 함수가 주로 I/O 연산에 시간을 보낸다면, 스레드를 추가한다. (process 함수만 변경)

### 서버 살펴보기
> 서버 코드가 지는 책임
* 소켓 연결 관리
* 클라이언트 처리
* 스레드 정책
* 서버 종료 정책
=> 불행히도 이 모든 책임은 process 함수가 진다! (분할 필요)

서버 프로그램 고칠 이유? 단일 책임 원칙(SPR) 위반 
스레드 관리를 한 곳으로! ->스레드 관리 전략 변경 시 전체 코드에 미치는 영향 감소, 동시성 정책 변경도 쉬움


### 결론
> 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요!

***

## 가능한 실행 경로
> 루프나 분기가 없는, 한 줄짜리 자바 메서드 
` public class IdGenerator {
	int lastIdUsed;

	public int incrementValue() {
		return ++lastIdUsed;
	}
} `
* 반환값은 lastIdUsed 값과 동일. 두 값 모두 메서드 호출하기 전보다 1이 크다.

lastIdUsed 초깃값을 93으로 가정할 때 가능한 결과
* 스레드 1이 94를 얻고, 스레드 2가 95를 얻고, lastIdUsed가 95가 된다.
* 스레드 1이 95를 얻고, 스레드 2가 94를 얻고, lastIdUsed가 95가 된다.
* 스레드 1이 94를 얻고, 스레드 2가 94를 얻고, lastIdUsed가 94가 된다.
-> 이처럼 다양한 결과 나오는 이유 알려면 가능한 실행 경로 수와 JVM의 동작 방식 알아야 함

### 경로 수
> 가능한 경로 수 계산하기 위해 자바 컴파일러가 생성한 바이트 코드 살펴보면...
> 두 스레드가 명령 8개를 뒤섞여 실행할 가능성 충분함.

> 루프나 분기 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로 수
	(NT)! / N!^T

> 가능한 순열 수 계산하기
	단계가 N개고 스레드가 T개라면 총 단계는 N*7개다.
	각 단계를 실행하기 전에는 스레드 T개 중 하나를 선택하는 문맥 전환 발생.
	그러므로 각 경로는 문맥 전환 나타내는 일련의 순열로 표현 가능.
	한 가지 특징 - 각 순열은 언제나 각 스레드를 N번 포함
	즉, 1이 N개, 2가 N개, ..... , T가 N개인 순열 수를 구하는 문제.
	단순히 N*T개를 일렬로 배열하는 순열 수에 중복하는 순열 수 빼주면 된다.

우리가 예제로 사용한 자바 코드 한 줄은 N=8, T=2 : 가능한 경로 수가 12,870 개.
만약 lastIdUsed가 long 정수라면 읽기/쓰기 명령은 한 단계가 아니라 두 단계로 실행. : 가능한 경로 수가 2,704,156개로 늘어남

> 만약 메서드를 이렇게 변경하면?
` public synchronized void incrementValue() {
	++lastIdUsed;
} `

가능한 경로 수는 (스레드가 2개일 때) 2개로 줄어든다!
스레드가 N개라면 가능한 경로 수는 N!이다.

### 심층 분석
앞서 (synchronized 추가하기 전에) 두 스레드가 메서드를 한 번씩 호출해 같은 값을 얻는 시나리오

> 원자적 연산이란? 중단이 불가능한 연산

> 바이트 코드를 상세히 보기전 명심해야 할 정의 세 가지
* 프레임(frame) - 모든 메서드 호출에는 프레임이 필요하다. 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수 포함한다. 프레임은 호출 스택(call stack)을 정의할 때 사용하는 표준 기법. 현대 언어는 호출 스택으로 기본 함수/메서드 호출과 재귀적 호출 지원.
* 지역 변수(local variables) - 메서드 범위 내에 정의되는 모든 변수. 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역 변수 갖는다. this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킴.
* 피연산자 스택(operand stack) - JVM이 지원하는 명령 대다수는 매개변수를 받는다. 피연산자 스택은 이런 매개변수 저장하는 장소. 피연산자 스택은 표준 LIFO 자료 구조. 

### 결론
> 스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해 바이트 코드를 속속들이 이해할 필요는 없지만, 어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델 이해하고 있어야 함.
* 공유 객체/값이 있는 곳
* 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
* 동시성 문제를 방지하는 방법

***

## 라이브러리를 이해하라
### Executor 프레임워크
> 스레드 풀 관리, 풀 크기 자동으로 조정, 필요하다면 스레드 재사용
> (다중 스레드 프로그래밍에서 많이 사용하는) Future 지원, Runnable 인터페이스를 구현한 클래스 및 Callable 인터페이스를 구현한 클래스도 지원.


### 스레드를 차단하지 않는 방법
스레드를 차단하지 않는 버전은 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발 
많은 스레드가 경쟁하는 상황이라도 락을 거는 쪽보다 문제를 감지하는 쪽이 거의 항상 더 효율적.

### 다중 스레드 환경에서 안전하지 않은 클래스
* SimpleDateFormat
* 데이터베이스 연결
* java.util 컨테이너 클래스
* 서블릿

해결 방안
* 먼저 HashTable을 잠근다. HashTable을 사용하는 클라이언트 모두가 클라이언트-기반 잠금 메커니즘을 구현한다.
* HashTable을 객체로 감싼 후 다른 API를 사용한다. ADAPTER 패턴을 사용해 서버-기반 잠금 메커니즘을 구현한다.
* 스레드에 안전한 집합 클래스를 사용한다.

***

## 메서드 사이에 존재하는 의존성을 조심하라
>해결 방안 세 가지
* 실패를 용인한다.
* 클라이언트를 바꿔 문제를 해결한다. 즉, 클라이언트-기반 잠금 메커니즘을 구현한다.
* 서버를 바꿔 문제를 해결한다. 서버에 맞춰 클라이언트도 바꾼다. 즉, 서버-기반 잠금 메커니즘을 구현한다. 

> 서버-기반 잠금이 더 바람직한 이유
* 코드 중복이 줄어든다.
* 성능이 좋아진다.
* 오류가 발생할 가능성이 줄어든다.
* 스레드 정책이 하나.
* 공유 변수 범위가 줄어든다.
* (서버 코드에 손대지 못한다면) ADAPTER 패턴 사용해 API 변경 후 잠금 추가한다.
* (더 좋은 방법) 스레드에 안전하고 인터페이스가 확장된 집합 클래스 사용한다.

***

## 작업 처리량 높이기
### 작업 처리량 계산 - 단일 스레드 환경
* 페이지를 읽어오는 평균 I/O 시간: 1초
* 페이지를 분석하는 평균 처리 시간: 0.5초
* 처리는 CPU 100% 사용, I/O는 CPU 0% 사용 

### 작업 처리량 계산 - 다중 스레드 환경
만일 스레드 세 개를 사용한다면, 단일 스레드 환경과 비교해 처리율은 세 배다.

***

## 데드락
> 개수가 한정된 자원 풀 두 개를 공유하는 웹 어플리케이션 있다고 가정
* 로컬 임시 데이터베이스 연결 풀
* 중앙 저장소 MQ 연결 풀 

> 애플리케이션은 생성과 갱신이라는 연산 두 개 수행
* 생성 - 중앙 저장소 연결 확보 후 임시 데이터베이스 연결 얻음. 중앙저장소와 통신한 후 임시 데이터베이스에 작업 저장.
* 갱신 - 임시 데이터베이스 연결 확보 후 중앙 저장소 연결 얻음. 임시 데이터베이스에서 작업을 읽어 중앙 저장소로 보냄. 

> 데드락이 발생하는 네 가지 조건 (모두 만족해야)
* 상호 배제
* 잠금 & 대기
* 선점 불가
* 순환 대기

### 상호 배제
> 여러 스레드가 한 자원을 공유하나 그 자원이,
> 여러 스레드가 동시에 사용하지 못하며 개수가 제한적이라면
> 상호 배제 조건을 만족한다.
> 예: DB 연결, 쓰기용 파일 열기, 레코드 락, 세마포어 등...

### 잠금&대기
> 일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.

### 선점 불가
> 한 스레드가 다른 스레드로부터 자원을 빼앗지 못 한다. 자원을 점유한 스레드가 스스로 내놓지 않는 이상 다른 스레드는 그 자원을 점유하지 못 한다.

### 순환 대기
> 죽음의 포옹이라고도 함.
> T1, T2 라는 스레드 두 개 / R1, R2 라는 자원 두 개 있다고 가정.
> T1이 R1 점유, T2가 R2 점유한다. 또한 T1은 R2가 필요하고 T2도 R2가 필요하다. 

### 네 조건 모두를 충족해야 데드락이 발생한다. 네 조건 중 하나라도 깨버리면 데드락은 발생하지 않는다.

### 상호 배제 조건 깨기
* 동시에 사용해도 괜찮은 자원을 사용한다. 예) AtomicInteger
* 스레드 수 이상으로 자원 수 늘인다.
* 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.

### 잠금 & 대기 조건 깨기
> 대기하지 않으면 데드락 발생X, 각 자원 점유하기 전에 확인.
> 만약 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원 몽땅 내놓고 처음부터 다시 시작.

이 방법의 잠재적인 문제 몇 가지
* 기아 - 한 스레드가 계속해서 필요한 자원을 점유 못 함.
* 라이브락 - 여러 스레드가 한꺼번에 잠금 단계로 진입하는 바람에 계속해서 자원을 점유했다 내놨다를 반복.


### 선점 불가 조건 깨기
> 다른 스레드로부터 자원을 뺏어오는 방법.

### 순환 대기 조건 깨기
* 자원을 할당하는 순서가 자원을 사용하는 순서가 다를지도 모른다. 그래서 맨 처음 할당한 자원을 아주 나중에야 쓸지 모른다. 즉, 자원을 꼭 피룡한 이상으로 오랫동안 점유한다.
* 때로는 순서에 따라 자원 할당하기 어렵다. 첫 자원 사용한 후에야 둘째 자원 ID를 얻는다면 순서대로 할당하기 불가능함.

***

## 다중 스레드 코드 테스트 
> 코드에 버그가 있는지 없는지 어떻게 찾아낼까?
* 몬테 카를로 테스트 : 조율이 가능하게 유연한 테스트 생성. 그 다음, 임의로 값 조율하면서 반복해 돌림. 테스트가 실패하면 버그 있다는 증거. 테스트는 일찌감치 작성하기 시작해 통합 서버에서 계속 돌림.
* 시스템을 배치할 플랫폼 전부에서 테스트 돌린다. 반복해서 돌린다. 계속해서 돌린다. 테스트가 실패 없이 오래 돌아갈수록 두 가지 중 하나일 확률.
	- 실제 코드가 올바르다.
	- 테스트가 부족해 문제를 드러내지 못한다.
* 부하가 변하는 장비에서 테스트를 돌린다. 실제 환경과 비슷하게 부하를 걸어줄 수 있다면 그렇게 한다.

***

## 스레드 코드 테스트를 도와주는 도구
> IBM - ConTest 사용법
* 실제 코드와 테스트 코드 작성. 앞서 언급했듯, 다양한 부하 상황에서 여러 사용자를 시뮬레이션하는 테스트 빼놓지 않음.
* ConTest로 실제 코드와 테스트 코드에 보조 코드 추가.
* 테스트 실행.
