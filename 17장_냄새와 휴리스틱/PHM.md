# 17장 냄새와 휴리스틱

## 주석
### 부적절한 정보
> 주석은 코드와 설계에 기술적인 설명을 부연하는 수단임을 잊지 말 것!

* 다른 시스템에 저장할 정보

### 쓸모없는 주석
> 주석은 빨리 낡는다!

* 오래된 주석
* 코드와 무관한 주석

### 중복된 주석
```java
i++ // i증가
```

### 성의없는 주석
* 문법을 바르게 사용한다
* 가능한 간결하고 명료하게 작성한다

### 주석처리된 코드
* 코드는 주석처리하지 말고 즉각 지울것!

<br/>
<br/>
<br/>

## 환경
### 여러 단계로 빌드하지 마라
* 빌드는 하나의 명령으로 전체를 체크아웃하여 한 명령으로 끝날 수 있도록 하기

### 여러 단계로 테스트하지 마라
* 모든 단위테스트는 하나의 명령으로 실행되어야 함
* 단위테스트가 쉬워야 자주 테스트를 시도할 수 있음!

<br/>
<br/>
<br/>


## 함수
### 너무 많은 인수
> 인수의 개수는 적을수록 좋다. 없으면 더욱 좋다.

### 출력 인수
* 출력 인수 대신 함수에 속한 객체 상태 변경을 활용하라

>#### 🖨 출력 인수란?
> ```java
> public void Test(Stack stack){
>   stack.push("여기서 stack이 바로 출력인수!");
> }
> ```

### 플래그 인수
* 플래그 인수는 혼란을 초래하므로 지양하라

>#### 🎏플래그 인수란?
>호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수 **..라는데 뭔소린지 모르겠어서 예시를 찾았다.**
>```java
>public Booking book (Customer aCustomer, boolean isPremium) {
>      if(isPremium) {..} //여기서 isPremium이 플래그 인수!
>      else {...}
>    }
>```
>#### 🤓 플래그 인수 대신 분리된 클래스를 사용하자!
>```java
>//if/else 문 수만큼 클래스를 만들어라~~
>public Booking regularBook(Customer aCustomer) {...}
>public Booking premiumBook(Customer aCustomer) {...}
>```

### 죽은 함수
* 호출되지 않는 함수는 삭제하라

<br/>
<br/>
<br/>

## 일반
### 한 소스에 여러 언어를 사용하지 마라
* 소스파일 하나당 하나의 언어만을 사용하라

### 당연한 동작을 구현하지 말아라
* 최소 놀람의 원칙에 의거하여 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 함

> #### ⛑ 최소 놀람의 원칙
> 코드를 작성할 때는 코딩 컨벤션을 따르고 주석과 명명을 통해 올바르게 의미를 전달해야 한다!


### 경계를 올바르게 처리하라
* 모든 경계조건을 찾아내라
* 모든 경계조건과 예외에서 코드를 테스트하라

### 안전 절차를 무시하지 마라
* 직접 제어하지 마라!
* 실패한 테스트를 치워두지 마라!

### 중복  
> #### 🏜 DRY 원칙
> Don't Repeat Yourself - 중복을 허용치 말라는 프로그래밍 원칙


* 중복된 코드는 하위 루틴이나 다른 클래스, 함수 등으로 분리하여 추상화 수준을 높여라
* 여러 모듈에서 if,switch 등으로 같은 조건을 확인하는 중복
  * 다형성으로 대체하라
* 알고리즘이 유사하나 코드가 서로 다른 경우
  * Template method pattern     
  * Strategy pattern
  
  
> #### Template method pattern
>상속을 통해 구조는 바꾸지 않으면서 특정 단계에서 수행하는 방법만을 바꾸는 패턴.
>![](https://velog.velcdn.com/images/0506phm/post/25b84544-cb79-4d49-bc2a-80689423b698/image.png)


> #### Strategy pattern
>같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고, 이들이 필요할 때 교체하는 패턴
>![](https://velog.velcdn.com/images/0506phm/post/afb65684-942b-4b69-9f4d-8d1a80bb3434/image.png)



### 추상화 수준을 올바르게 유지하라
> 추상화 - 저차원 상세 개념에서 고차원 일반 개념을 분리한다

* 저차원 개념은 파생 클래스에, 고차원 개념은 기초 클래스에 넣어라
  * 기초 클래스 - 구현 정보에 대해 아무것도 모른다!
  * 파생 클래스 - 세부 구현과 관련된 상수, 변수, 유틸리티 함수를 여기서 구현하라!

### 기초 클래스가 파생 클래스에 의존해서는 안 된다
> 개념을 나누는 이유는 **기초 클래스를 파생 클래스로부터 분리해 독립성을 보장**하기 위함이다!

* 기초 클래스는 파생 클래스를 몰라야 한다!
* 기초 클래스를 독립적인 개별 컴포넌트 단위로 배포하여 유지보수를 편하게 하라!

### 과도한 정보
> 잘 정의된 인터페이스는 많은 함수를 제공하지 않는다.

* 클래스가 제공하는 메서드의 수는 작을수록 좋다
* 함수가 아는 변수 수는 작을수록 좋다
* 클래스에 들어있는 인스턴스 수는 작을수록 좋다
* 인터페이스를 작고 깐깐하게 만들어라
* 정보를 제한해 결합도를 낮춰라

### 죽은 코드
* 실행되지 않는 코드는 지워라
  * 불가능한 조건을 확인하는 IF문
  * throw없는 try에서의 catch문

### 수직 분리
* 변수와 함수는 사용되는 위치에 가깝게 정의하라
  * 지역 변수는 처음 사용 직전에 사용하라
  * 비공개 함수는 호출 직후 정의하라
  

> #### 🏄‍♀️ 익스트림 프로그래밍(XP)
> 켄트 백이 제안한 소프트웨어 개발 방법으로, 테스트를 기반으로 프로젝트를 완성시키는 방법. <br/>
> 애자일 개발 프로세스라 불리는 개발 방법 중의 대표적인 하나이다.

  
### 일관성을 유지하라
* 개념 구현 방식을 일관적으로 유지하라
  * 최소 놀람의 원칙을 명심하라!
* 일단 선택한 표기법을 신중하게 따라라

### 잡동사니를 제거하라
* 사용하지 않는 변수는 제거하라
* 호출하지 않는 함수는 제거하라

### 인위적으로 결합하지 마라
* 무관한 개념을 결합시키지 마라
* enum이 클래스에 속한다면 enum사용 코드는 해당 클래스를 알아야 한다!
* 범용 static 함수를 특정 클래스에 넣지 마라!
* 뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 위치에 넣지 마라!

### 기능을 욕심내지 마라
> 클래드 메서드는 자기 변수와 함수에만 관심을 가져야 한다

* 다른 객체의 참조자와 변경자를 사용하여 해당 객체 내 내용을 조작하게 하지 마라

### 선택자 인수

* 선택자 인수 사용을 지양하라
  * 선택자 인수는 목적을 확인하기 어렵다
  * 대신 큰 함수를 작은 함수 여럿으로 쪼개라!

> #### 🛒 선택자 인수
>```java
>// 받은 인수가 true인지 false인지 확인하는 것보다..
>public int calculPay(boolean overtime){
>    int overtimePay = overtime ? getOvertimePay() : 0 ;
>    return getPay() + overtimePay;
>}
>// 동작(확인)은 다른 함수에게 맡기고 나온 값을 가져오는 것만 한다!
>public int calculPay(){
>	int overTimePay = overTimeBonus(getOvertime());
>	return getPay() + overtimePay;
>}
>```

### 모호한 의도
* 코드를 짤 때는 의도를 최대한 분명히 밝힌다!
   * 수식을 가독성 있게 작성한다
   * 헝가리식 표기법, 매직 넘버는 사용을 지양한다

> #### 🎩 매직 넘버
>의미가 분명하지 않은 모든 토큰. <br/>
>상수(static final)로 선언하지 않은 숫자가 대표적이다.


### 잘못 지운 책임
* 최소 놀람의 원칙에 따라 코드는 독자가 당연하게 기대하는 위치에 배치하도록 노력한다!
* 책임 대상을 결정할 때는 함수 이름에 의거하여 결정한다

### 부적절한 static 함수
>일반적으로 static함수보다, 인스턴스 함수가 더 좋다!

* 함수를 재정의할 가능성이 존재한다면 static을 사용하지 않아야 한다

### 서술적 변수를 사용하라
* 계산을 여러 단계로 나누고 중간값으로 서술적 변수를 사용하여 가독성을 높여라

### 이름과 기능이 일치하는 함수를 작성하라
* 이름만으로 기능을 추측할 수 없다면..
  * 더 좋은 이름으로 바꾸어야 한다.
  * 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.
  
### 알고리즘을 이해해라
* 함수가 돌아가는 방식을 확실히 이해하고 있는지 확인하라
* 기능이 확실하게 보이도록 함수를 깔끔하고 명확하게 재구성하라

### 논리적 의존성은 물리적으로 드러내라
>양복점에서는 먼저 실측을 하지 않으면 실제 재봉을 진행할 수 없습니다.
>이것이 진정한 논리적 종속성입니다. -Steve Pogue-

* 의존하는 모듈이 상대 모듈에 의존한다면, 의존하는 모든 정보를 명시적으로 요청해라

```java
//논리적 의존성이 드러나지 않은 예
public int size;
public class SizeMeasure{
    public void setSize(int size){size=this.size;}
}
public class ClothesSew{
	public void clothesSewing(){
    	Cutting(size);
    //size가 null이므로 반드시 setSize를 진행하고 해당 함수를 진행해야 한다..
    //그러나 함수에는 그것이 드러나지 않았다!
    }
}

//논리적 의존성이 물리적으로 드러난 예
public class SizeMeasure{
	private int size;
    public void setSize(int size){size=this.size;}
    public int getSize(){return size;}
}
public class ClothesSew{
	public void clothesSewing(){
    	SizeMeasure sm = new SizeMeasure(); //의존성이 드러났다~~
    	sm.setSize(10);
        Cutting(sm.getSize());
    }
}
```

### if나 switch문보다 다형성을 사용하라
* switch를 사용하기 전에 다형성을 사용할 수 있는지를 고려하라

> #### 👑 switch문 하나 규칙
>선택 유형 하나에는 switch문을 한번만 사용하는 규칙.
>같은 선택을 수행하는 다른 코드에서는 다형성 객체로 switch를 대신한다.
>```java
>class WorkingDay{
>	private Day day;
>    public WorkingDay(int today){
>      switch(today) {
>        case 1: this.day=Sunday; break;
>        case 2: this.day=MonDay; break;
>        ...
>      }
>	}
>}
>//위에서 switch를 썼으므로, 아래에서 요일을 선택할 때는 다형성 객체로 대신한다
>function Date(int today){
>	WorkingDay wd = new WorkingDay(today);
>    int workingTime = wd.day.getWorkingtime();
>    //switch문으로 요일에 따른 일한시간을 구하는 것이 아닌,
>    //다형성 객체에서 일한시간을 꺼낸다~
>}
>```


### 표준 표기법을 따르라
>실제 괄호를 넣는 위치는 중요하지 않다. 모두 동의한 곳에 넣는다는 사실이 중요하다!

* 업계 표준에 기반한 구현 표준을 따르라
  * 인스턴스 변수 이름을 선언하는 위치
  * 클래스/메서드/함수 이름을 정하는 방법
  * 괄호를 넣는 위치
* 표준을 설명하는 문서가 별도로 필요 없도록 코드를 충실하게 작성하라

### 매직 숫자는 명명된 상수로 교체하라
* 숫자는 상수 뒤로 숨겨라
  * 단, 공식이나 수식 등에 사용되는 당연한 숫자는 숨기지 않아도 된다~


### 정확하라
* 부동소수점으로 통화를 표현하지 마라!
* 갱신할 가능성이 희박하다고 잠금과 트랜잭션 관리를 건너뛰지 마라!
* 코드에서 무언가를 결정할 때는 정확하게 결정해라
  * 결정을 내리는 이유를 명확히 해라
  * 예외를 분명하게 처리해라
* null을 점검하라
* 조회 결과의 수가 올바른지 확인하라
* 동시 갱신 가능성이 있는 부분은 적절한 잠금 매커니즘을 구현하라

### 관례보다 구조를 사용하라
* 설계 결정을 강제할 때는 규칙보다 관례를 사용한다.
* 명명 관례도 좋지만 구조 자체로 강제하면 더 좋다.

#### 😌 그렇다. 뭔소린지 모르겠다.
그래서 원문을 확인했다.
>G27: Structure over Convention <br/>
>"Enforce design decisions with structure over convention. Naming conventions are good, but they are inferior to structures that force compliance. "

역자는 convention을 "관례"라고 번역했다. 여기서 말하는 convention에 대해 정확한 정의를 찾아 보니..
> coding convention이란 해당 언어로 작성된 프로그램의 각 측면에 대한 프로그래밍 스타일, 관행 및 방법을 권장하는 특정 프로그래밍 언어에 대한 일련의 지침이자 소프트웨어 구조적 품질에 대한 지침입니다 
>> 파일 구성, 들여쓰기, 주석, 선언, 명령문, 공백, 명명 규칙, 프로그래밍 관행, 프로그래밍 원칙 등..

..그러니까 코드 작성 규칙을 일컫는 말인 것 같다.
즉 다음과 같이 풀어서 해석할 수 있겠다.
>코드를 설계할 때 정해져 있는 코딩 규칙을 그대로 따르기보다는 해당 코드의 구조를 더 참고해서 결정하는 것이 좋다. 그리고 명명 관례를 따르는 것도 좋지만 내가 만들고 싶은 구조로 만들어서 그걸 준수하면 더 좋다. **결론은 나 편한대로 짜는게 제일이다....**

(enforce에 그냥 "시행한다"는 뜻도 있는데, 역자가 "강제한다" 번역을 해서 의미가 이게 뭔 소리냐 싶어진 것 같음....)

😥확신이 없다.. 해설본이 필요하다..


### 조건을 캡슐화하라
* 부울 논리보다 if문 내 의도를 명확히 밝히는 하나의 함수를 만들어라

### 부정 조건을 피하라
* 부정 조건은 긍정조건보다 이해하기 어렵다!

### 함수는 한 가지만 해야 한다
* 여러 일을 하는 함수가 있다면, 쪼개라!

### 숨겨진 시간적 결합을 드러내라
* 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러내라
* 연결 소자를 이용해 시간적 결합을 강제해라

### 일관성을 유지하라
* 코드 구조를 설계할 때는 이유를 고민하고 구조로 표현하라
* 시스템 전반에 걸쳐 해당 구조를 일관성있게 유지하라


### 경계 조건을 캡슐화하라
* 경계 조건을 하나의 상수로 만들어라

### 함수는 추상화 수준을 한 단계만 내려가야 한다
* 함수 내 모든 문장은 추상화 수준이 동일해야 한다

> #### 🥇 추상화 수준
> ![image](https://user-images.githubusercontent.com/62527898/185350931-36fd16a5-f2f9-43b1-a51a-cf7dc6ac6509.png)

### 설정 정보는 최상위 단계에 둬라
* 기본값 상수, 설정 관련 상수는 최상위 단계에 두어라
  * 설정 관련 변수는 고차원 함수에서 저차원 함수를 호출할 때 인자로 넘겨라
  * 저차원 함수에 상수 값을 정의하지 마라
  

### 추이적 탐색을 피하라
> 한 모듈은 주변 모듈을 모를수록 좋다

* 모듈은 자신이 직접 사용하는 모듈에 대해서만 알아야 한다
* 내가 사용하는 모듈이 내게 필요한 서비스를 모두 제공해야 한다
  * 원하는 메서드를 찾아 객체를 타고 타고 이동해서는 안 된다

>#### 👥 추이적이란?
>aRb이고 bRc이면 aRc인 것을 일컫는 표현. 즉 타고 타고 내려가는 것!

>#### 🌾 디미터(데메테르)의 법칙
>최소한의 지식 원칙을 강조하여, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙

>#### 😳 부끄럼 타는 코드 
>코드는 수줍어야 합니다. 다른 사람에게 자신을 드러내지 않고 너무 많은 사람들과 상호 작용하지 않아야 합니다.


<br/>
<br/>
<br/>

## 자바
### 긴 import목록 대신 와일드카드(*)를 사용해라
* import문은 패키지를 단순히 검색 경로에 추가할 뿐, 진정한 의존성을 의미하지 않는다.

### 상수는 상속하지 않는다
> 상수 상속은 언어 범위 규칙을 속이는 행위이다!

* 상위 계층으로부터의 상수 상속 대신 static import를 사용하라

### 상수 대 Enum
* public static final int 대신 enum을 사용하라

<br/>
<br/>
<br/>

## 이름
### 서술적인 이름을 사용하라
>소프트웨어 가독성의 90%은 이름이 결정한다

### 적절한 추상화 수준에서 이름을 선택하라
* 구현을 드러내는 이름을 피해라
* 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라
   * ex) face의 바로 하위 클래스 이름으로는 eyes, mouth, ears등을 사용하는 것이 tooth, drumhead등을 사용하는 것보다 적절하다.

### 가능한 표준 명명법을 사용하라
* 사용하는 패턴명을 이름에 넣어라
* 관례적인 함수명을 사용해라

> #### 🔊 유비쿼터스 언어
>도메인과 관계된 사람들이 공통적으로 의미를 이해할 수 있도록 정의하는 모든 단어나 용어들

### 명확한 이름
* 목적을 정확히 밝히는 이름을 사용하라
* 길어도 서술성이 충분하다면 사용하라

### 긴 범위는 긴 이름을 사용하라
* 이름 길이는 범위 길이에 비례해야 한다

### 인코딩을 피하라
* 이름에 유형이나 범위 정보를 넣지 마라
  * 불필요한 접두어
  * 헝가리안 표기법

### 이름으로 부수 효과를 설명하라
* 하는 일을 모두 기술하는 이름을 사용하라


<br/>
<br/>
<br/>

## 테스트

### 불충분한 테스트
* 테스트 케이스는 잠재적인 위험이 있는 모든 곳을 테스트해야한다

### 커버리지 도구를 사용하라
* 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다

### 사소한 테스트를 건너뛰지 마라
> 사소한 테스트가 제공하는 문서적 가치가 구현에 드는 비용보다 크다!

### 무시한 테스트는 모호함을 뜻한다
* 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 @ignores를 붙인다
   * 모호함의 기준은 컴파일 가능 여부로 판단한다!
   
### 경계 조건을 테스트하라

### 버그 주변을 철저히 테스트하라
* 버그는 서로 모이는 경향이 있다!

### 실패 패턴을 살펴라
* 테스트 케이스 실패 패턴으로 문제를 진단하라

### 테스트 커버리지 패턴을 살펴라
* 성공 테스트 케이스가 실행하거나 실행하지 않는 코드에서~~이건 모든 코드란 소리 아닌가..?~~ 실패 테스트 케이스의 원인이 존재한다

### 테스트는 빨라야 한다

## 결론
> 전문가 정신과 장인 정신은 가치에서 나온다.
> 그 가치에 기반한 규율과 절제가 필요하다.
