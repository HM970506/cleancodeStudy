3장 함수
=========
어떤 프로그램이든 가장 기본적인 단위가 함수다.  
나쁜 코드에서의 함수는 길이가 길 뿐만 아니라 중복된 코드에, 괴상한 문자열에, 낯설고 모호한 자료 유형과 API가 많다.  
<br>
### 함수를 만드는 규칙
__1. 작게 만들어라!__
> 함수는 작고 명백해야 한다.  
> if/else 문, while 문 등에 들어가는 블록은 한 줄이어야 하며 대개 거기서 함수를 호출하는 것이 좋다.  
> 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
> 중첩 구조가 생길만큼 함수가 커져서는 안 된다.

<br>

__2. 한 가지만 해라!__
> 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.   
> 또한 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있는지를 통해 함수가 '한 가지'만 하는지 판단할 수 있다.

<br>

__3. 함수 당 추상화 수준은 하나로!__
> 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.  
> 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.  
> 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다.
> > _* 내려가기 규칙: 위에서 아래로 코드 읽기_  
> > 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.  
> > 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
>
> 핵심은 짧으면서도 '한 가지'만 하는 함수다.  
> 위에서 아래로 TO 문단을 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기 쉬워진다.

<br>

__4. switch__
> switch 문은 작게 만들기 어려우며 '한 가지' 작업만 하는 switch 문도 만들기 어렵다.  
> 불행하게도 switch 문을 완전히 피할 방법은 없지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 물론 다형성을 이용한다.  
> 저자의 방법은 switch 문을 추상 팩토리에 숨기는 것이다.

<br>

__5. 서술적인 이름을 사용하라!__
> 서술적인 이름을 통해 함수가 하는 일을 좀 더 잘 표현하는 것이 좋다.  
> 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.  
> 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.  
> 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.  
> 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.  
> 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.

<br>

__6. 함수 인수__
> 함수에서 이상적인 인수 개수는 0개(무항)이고 다음은 1개(단항), 그 다음은 2개(이항)이다. 3개(삼항) 이상은 가능한 피하는 편이 좋다.  
> 인수는 개념을 이해하기 어렵게 만들며 테스트 또한 어렵게 만든다.  
> 출력 인수는 입력 인수보다 이해하기 어렵다.
> >_* 많이 쓰이는 단항 형식_  
> > 함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다.
> > 1. 인수에 질문을 던지는 경우
> > 2. 인수를 뭔가로 변환해 결과를 반환하는 경우
> >
> > 유용한 단항 함수 형식 '이벤트 함수'  
> > 이벤트 함수는 입력 인수만 있고 출력 인수는 없다.  
> > 프로그램은 함수 호출을 이벤트로 해석해 입력 인수로 시스템 상태를 바꾼다.  
> > 이벤트 함수는 이벤트라는 사실이 코드에 명확히 드러나야 하므로 이름과 문맥을 주의해서 조심해서 사용해야 한다.  
> > 지금까지 설명한 경우가 아니라면 단항 함수는 가급적 피한다. 입력 인수와 출력 인수 사이의 혼란을 야기할 수 있기 때문이다.  
> > 입력 인수를 그대로 돌려주는 함수라 할지라도 되도록 변환 함수 형식을 따르는 편이 좋다.
>
> >_* 플래그 인수_  
> > 플래그 인수는 좋지 않다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다.  
> > 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하기 때문이다.
>
> >_* 이항 함수_  
> > 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.  
> > 물론 더하기 함수와 같이 이항 함수가 적절한 경우도 있다.  
> > 하지만 이항 함수는 인수 2개가 한 값을 표현하는 지의 여부, 요소들 사이에 자연적인 순서의 존재 여부 등에 따라 위험이 따른다.  
> > 따라서, 위험성을 인지하고 가능하면 단항 함수로 바꾸도록 애써야 한다.
>
> >_* 삼항 함수_  
> > 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어려우며 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다.  
> > 그래서 삼항 함수를 만들 때는 신중히 고려하라 권고한다.
>
> >_* 인수 객체_  
> > 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어 본다.  
> > 객체를 생성해 인수를 줄이는 방법은 이름을 붙여야 하므로 결국은 개념을 표현하게 된다.
>
> >_* 인수 목록_  
> > 때로는 인수 개수가 가변적인 함수도 필요하다. 대표적으로 String.format 메서드가 있다.
>
> >_* 동사와 키워드_  
> > 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.  
> > 함수 이름에 인수를 넣는다면 인수 순서를 기억할 필요가 없어지므로 함수의 의도나 인수의 순서를 제대로 표현할 수 있다.

<br>

__7. 부수 효과를 일으키지 마라!__
> 남몰래 다른 효과를 불러일으킨다. 많은 경우 시간적인 결합(temporal coupling)이나 순서 종속성(order dependency)을 초래한다.  
> 특히 부수 효과로 숨겨진 경우에는 의도하지 않은 혼란이 커질 수 있다.  
> 따라서, 시간적 결합이 필요하거나 순서 종속성이 필요하다면 함수 이름에 분명히 명시하는 것이 좋다.(물론, 함수가 '한 가지'만 한다는 규칙을 위반하지 않게 주의해야 한다.)
> >_* 출력인수_
> > 일반적으로 우리는 인수를 함수 입력으로 해석한다.  
> > 객체 지향 프로그래밍이 나오기 전에는 출력 인수가 불가피한 경우도 있었지만 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다.  
> > 출력 인수로 사용하라고 설계한 변수가 바로 this이기 때문이다.  
> > 따라서, 일반적으로 출력 인수를 피해야 한다.

<br>

__8. 명령과 조회를 분리하라!__
> 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.  
> 즉, 혼란을 초래하지 않기 위해 함수는 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나여야 한다.  
> 진짜 해결책은 명령과 조회를 분리해 혼란을 애초에 뿌리뽑는 방법이다.

<br>

__9. 오류 코드보다 예외를 사용하라!__
> 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 또한 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다.  
> 반면 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.
> > _* Try/Catch 블록 뽑아내기_  
> > try/catch 블록은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.  
> > 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.  
> > 이렇게 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다.
>
> > _* 오류 처리도 한 가지 작업이다._  
> > 함수는 '한 가지' 작업만 해야 하고 오류 처리도 '한 가지' 작업에 속한다.  
> > 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.
>
> > _* Error.java 의존성 자석_
> > 오류 코드를 반환한다는 이야기는, 클래스든 열거형 변수든, 어디선가 오류 코드를 정의한다는 뜻이다.  
> > 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생된다.  
> > 따라서 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다.

<br>

__10. 반복하지 마라!__
> 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 중복된 모든 곳을 손봐야 한다.  
> 저자는 include 방법으로 중복을 없앴다.  
> 중복을 없앴더니 모듈 가독성이 크게 높아진 점을 확인할 수 있다.  
> 데이터베이스의 정규 형식, 객체지향 프로그래밍의 부모 클래스, 구조적 프로그래밍, AOP(Aspect Oriented Programming), COP(Component Oriented Programming) 모두 어떤 면에서 중복 제거 전략이다.

<br>

__11. 구조적 프로그래밍__
> 구조적 프로그래밍의 목표와 규율은 공감하지만 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다.

함수를 짤 때 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거하고, 메소드를 줄이고 순서를 바꾸며 읽기 좋게 다듬어야 한다.

<br>

__결론__  
프로그래밍 기술은 언제나 언어 설계의 기술이다.   
대가 프로그래머는 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어 이야기를 풀어간다.  
이 장에서 설명한 함수를 잘 만드는 기교는 이를 수월하게 할 수 있도록 도와준다.
