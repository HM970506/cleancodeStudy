> 개발자는 코드를 짤 때, 오로지 자신이 개발한 코드만 사용하는 경우는 드물다. 패키지를 사거나 오픈 소스를 이용하는 경우가 많다. 외부 코드를 가져와서 사용할 때도 깔끔하게 사용해야 한다.

# 외부 코드 사용하기
인터페이스 제공자는 최대한 많은 사람에게 제공하고자 하고, 인터페이스 사용자는 자신에게 집중하는 인터페이스를 원하기 때문에 시스템의 경계에는 문제가 생길 여지가 많다.
ex) **java.util.Map**
- 제공하는 method
```java
clear() void
containsKey(Object key) boolean
containValue(Object value) boolean
isEmpty() boolean
keySet() set
...
```
1. 프로그램에서 Map을 생성하고 마구 넘기는 경우, clear()를 사용하여 내용을 지울 수 있다.
2. Map은 객체 유형을 제한하지 않기 때문에 사용자가 마음대로 바꿀 수 있다.
-> Generics을 사용하면 코드 가독성이 높아질 수 있다.
하지만 Map 인터페이스가 바뀌게 되는 경우, 코드를 모두 바꿔야 한다.🥲
```java
    Map<String, Sensor> sensors = new HashMap<String, Sensor>();
    ...
    Sensor s = sensors.get(sensorId);
```
- 깔끔하게 사용한 Map 코드
-> Map을 Sensors 안으로 숨긴다. Map 인터페이스가 바뀌더라도 나머지 프로그램에는 영향을 주지 않는다.
```java
private class Sensors {
	private Map sensors = new HashMap();
    
    public Sensor getById(String id) {
    	return (Sensor)sensors.get(id);
    }
    
    ...
}
```

# 경계 살피고 익히기
외부 코드를 사용하게 되면 많은 기능을 빠르게 출시할 수 있게 된다.
하지만 외부 코드를 익히고 통합하는 것은 어렵다.
=> 간단한 테스트 케이스로 외부 코드를 익히고 사용하도록 한다.
=> **학습 테스트**

# 학습 테스트는 공짜 이상이다
학습 테스트에 드는 비용은 없다. 학습 테스트는 패키지가 원하는 대로 작동하는지 확인 할 수 있다. 학습 테스트로 빠르게 패키지의 이해도를 높여줄 수 있다. 

# 이미 존재하지 않는 코드를 사용하기
소프트웨어를 개발할 때 이해하기 어려운 경계와 마주칠 수 있다.

ex) 무선통신 시스템의 소프트웨어 개발
송신기라는 하위 시스템이 존재한다. 송신기 시스템을 책임진 사람들이 아직 구현을 하지 못한 상태이다.
-> 송신기 시스템과 먼 부분부터 구현하기 시작
-> 송신기 시스템은 인터페이스로 정의
=> 필요한 기능을 알아낼 수 있게 된다.

# 깨끗한 경계
소프트웨어 설계가 잘 된 코드는 변경하는데 큰 노력과 투자가 필요하지 않다.
외부 패키지를 호출하는 코드는 가능한 줄이는 것이 좋다.