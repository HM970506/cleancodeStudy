# 동시성⚙️
## ✅ 클라이언트/서버 예제
서버는 소켓을 여어놓고 클라리언트가 연결하기를 기다린다.
클라이언트는 소켓에 연결해 요청을 보낸다.
### 서버
서버는 연결을 기다린 후 돌아오는 메시지를 처리한 후 다음 클라이언트 요청을 기다린다.
```java
ServerSocket serverSocket = new ServerSocket(8009);

while(keepProcessing) {
	try {
    	Socket socket = serverSocket.accept();
        process(socket);
    } catch (Exception e) {
      	handle(e);
    }
}
```
### 클라이언트
서버에 연결하는 클라이언트 코드이다.
```java
private void connectSendReceive(int i){
	try{
    	Socket socket = new Socket("localhost", PORT);
        MessageUtils.sendMessage(socket, Integer.toString(i));
        MessageUtils.getMessage(socket); socket.close();
    } catch (Exception e) {
    	e.printStackTrace();
    }
}
    
```
### 테스트 코드로 성능 확인하기 👍
시스템이 일련의 클라이언트 요청을 10초 내에 처리해야 하는 테스트 코드를 진행했을 때, 테스트를 실패했다면? 성능을 높일 수 있는 방법에는 어떤것이 있을까?
> 시스템이 I/O와 프로세서를 이용해 기능들을 수행하는 시간을 보낸다.
> 이때, 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성의 성능을 높여주는 방법이 있다. 즉, 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용할 수 있다.

## ✅ 동시성의 성능을 높여보자!
### 스레드 추가하기
자료 처리량을 높여 테스트를 통과시켜보자.
서버의 process 함수가 주로 I/O 연산에 시간을 보낸다면, 다음처럼 스레드를 추가한다.
```java
void process(final Socket socket) {
	if (socket == null)
    	return;
        
    Runnable clientHandler = new Runnable() {
    	public void run(){
        	try{
            	String message = MessageUtils.getMessage(socket);
                MessageUtils.sendMessage(socket, "Processed: " + message);
            } catch (Exception e) {
            	e.printStackTrace();
            }
        }
    };
    Thread clientConnection = new Thread(clientHandler);
    clientConnection.start();
}     
```
### 서버 살펴보기
위 코드는 성능 테스트를 성공하지만 위 코드는 여러가지 문제가 있다.
#### 1. 동작 문제
- 코드에서 새로 만드는 스레드 수의 한계를 명시하지 않고있다.
- 이론상으로 JVM이 허용하는 수까지 가능하다.
#### 2. 다양한 책임
- process 함수가 지는 책임과 추상화 수준이 다양하다.
- 단일 책임 원칙을 위반하고 있다.
> - 소켓 연결 관리
> - 클라이언트 처리
> - 스레드 정책
> - 서버 종료 정책

위 문제를 해결하기 위해서 잘 통제된 몇 곳으로 스레드 관리를 모아야 한다.
즉, 앞서 열거한 책임마다 클래스를 만들어서 스레드 관리 전략이 바뀔 때마다 코드에 미치는 영향을 최소화 시키고 다른 책임을 간섭하지 않게 해야 한다.
> 💡 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다!

## ✅ 가능한 실행 경로
다중 스레드를 이용해 메서드를 한 번 씩 호출 한다면 실행 경로 수와 JVM의 동작 방식을 알아야 한다.
### 경로 수
- 단계가 N개이고 스레드가 T라면 총 단계는```N*T```개다. 
- 각 단계를 실행하기 전에는 스레드 T개 중 하나를 선택하는 문맥 전환이 일어나므로 각 경로는 문맥 전환을 나타내는 일련의 순열로 표현할 수 있다.
- 경로의 수는 ```(N*T)!/(N!**T)```이다.

> 만약 메서드에 ```synchronized``` 키워드를 붙이면 N개의 스레드에 대한 경로의 수는 ```N!```로 줄어들게 된다.

### 심층 분석
원자적 연산이란 중단이 불가능한 연산을 말한다. 즉, 처리 중간에 다른 것이 끼어들 여지를 주지 않는다. 원자적 연산을 사용하면 스레드의 결과가 예상과 다르게 나올 수 있는 문제점을 해결할 수 있다.
> 💡 ```++``` 연산은 원자적 연산이 아니예요!

## ✅ 라이브러리를 이해하라
### Executor 프레임워크
- 스레드 풀링으로 정교한 실행을 지원한다.
- 스레드 풀을 관리하고, 풀 크기를 자동으로 조정하며, 필요하다면 스레드를 재사용한다.
- Future, Runnable 구현 클래스, Callable 구현체 등을 지원한다.
### 스레드를 차단하지 않는 방법
- 최신 프로세서는 차단하지 않고도 안정적으로 값을 갱신한다.
- 동기화를 사용하여 스레드를 차단하지 않기 위해 자바5는 ```AtomicBoolean```, ```AtomicInteger```, ```AtomicReference```를 포함한 여러 클래스를 제공하고 있다. 이를 이용해 코드를 다시 짜면, 스레드를 차단하지 않을 뿐더러 성능도 좋다.
- 성능이 좋은 이유는? 현대 프로세서는 흔히 CAS라 불리는 연산을 지원한다. 
  - CAS는 낙관적 잠금이라는 개념과 비슷하다.
- 스레드를 차단하지 않는 버전은 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발한다.

  
### 다중 스레드 환경에서 안전하지 않은 클래스
- 본질적으로 다중 스레드 환경에서 안전하지 않은 클래스가 있다. 
- 몇몇 집합 클래스는 스레드에 안전한 메서드를 제공한다. 하지만 그런 메서드 여럿을 호출하는 작업은 스레드에 안전하지 않다.

## ✅ 메서드 사이에 존재하는 의존성을 조심하라
- 다중 스레드 환경에서 두 스레드가 서로를 간섭하면서 문제가 발생하게 된다.
> ###  3가지 해결 방법
> - 실패를 용인한다.
> - 클라이언트를 바꿔 문제를 해결한다. 
> - 서버를 바꿔 문제를 해결한다. 

### 실패를 용인한다
- 때로는 실패해도 괜찮도록 프로그램을 조정할 수 있다.

### 클라이언트-기반 잠금
- 각 클라이언트는 ```synchronized```키워드를 이용해 객체에 락을 건다.
- 서버를 사용하는 모든 프로그래머가 락을 기억해 객체에 걸었다 풀어야 하므로 다소 위험한 전략이다.

### 서버-기반 잠금
- 다중 스레드를 고려하게 클라스 API를 설계한다.
- 일반적으로 서버-기반 잠금이 더 바람직하다.
> - 코드 중복이 줄어든다.
> - 성능이 좋아진다.
> - 오류가 발생할 가능성이 줄어든다.
> - 스레드 정책이 하나다.  
> - 공유 변수 범위가 줄어든다.

## ✅ 작업 처리량 높이기
- 다중스레드 환경이 단일스레드 환경과 비교해 처리율이 세 배 높다.
## ✅ 데드락
- 데드락을 근본적으로 해결하려면 원인을 이해해야 한다.
- 다음 네 가지 조건을 모두 만족하면 데드락이 발생한다.
> - 상호 배제(Mutual exclusion)
> - 잠금 & 대기(Lock & Wait)
> - 선점 불가(No Preemption)
> - 순환 대기(Circular Wait)
> ### 상호배제
> - 여러 스레드가 한 자원을 공유하나 그 자원은 _**여러 스레드가 동시에 사용하지 못하며 개수가 제한적**_이라면 상호 배제 조건을 만족한다.
> ### 잠금 & 대기
> - 일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠때까지 이미 점유한 자원을 내놓지 않는다.
> ### 선점 불가
> - 한 스레드가 다른 스레드로부터 자원을 빼앗지 못한다.
> ### 순환 대기
> - 각 스레드는 순환적으로 다른 스레드가 요구하는 자원을 가지고 있다.

### 데드락 피하기1 - 상호배제조건 깨기
- 동시에 사용해도 괜찮은 자원을 사용한다.  
- 스레드 수 이상으로 자원 수를 늘린다.  
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.  
### 데드락 피하기2 - 잠금 & 대기 조건 깨기
- 대기하지 않으면 데드락이 발생하지 않는다.
- 각 자원을 점유하기 전에 확인하고, 만약 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작한다.
> 위 방법의 문제점
> -  기아(Starvation) - 한 스레드가 계속해서 필요한 자원을 점유하지 못한다.
> - 라이브락(Livelock) - 여러 스레드가 한꺼번에 잠금 단계로 진입하는 바람에 계속해서 자원을 점유했다 놨다를 반복한다.
>
두 경우 모두가 자칫하면 작업 처리량을 크게 떨어뜨린다.
기아는 CPU 효율을 저하시키는 반면 라이브락은 쓸데 없이 CPU만 많이 사용한다.
### 데드락 피하기3 - 선점 불가 조건 깨기
- 다른 스레드로부터 자원을 뺏어오는 방법이다.
- 필요한 자원이 잠겼다면 자원을 소유한 스레드에게 풀어달라 요청한다.
- 처리 방식은 간단하지만, 모든 요청을 관리하기가 그리 쉽지 않다.
### 데드락 피하기4 - 순환 대기 조건 깨기
- 데드락을 방지하는 가장 흔한 전략이다.
- 모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 데드락은 불가능하다. 
- 그러나 어느 전략과 마찬가지로 이 전략 역시 문제를 일으킬 소지가 있다.
## ✅ 다중 스레드 코드 테스트
실패를 증명할 테스트 코드는 어떻게 작성할까?

### 몬테 카를로 테스트
조율이 가능하게 유연한 테스트를 만들고 임의로 값을 조율하면서 반복해 돌린다.
- 테스트가 실패한 조건은 신중하게 기록한다.
- 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다.
- 부하가 변하는 장비에서 테스트를 돌린다.

하지만 위와 같은 조치를 모두 취하더라도 코드에서 스레드 문제를 찾아낼 가능성은 매우 낮다.

### 스레드 코드를 도와주는 도구
#### ConTest
- 스레드에 안전하지 않는 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구이다.
